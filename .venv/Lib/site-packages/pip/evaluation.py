import chess
from collections import defaultdict
import numpy as np

class Evaluation:
    def __init__(self, board, piece_values, pawn_table_opening=None, pawn_table_middlegame=None, pawn_table_endgame=None,
                 knight_table=None, bishop_table=None, rook_table=None, queen_table=None, king_table_opening=None,
                 king_table_endgame=None, use_nnue=True):
        self.board = board
        self.piece_values = piece_values
        self.use_nnue = use_nnue
        try:
            if use_nnue:
                from nnue import NNUE
                self.nnue = NNUE()
        except ImportError:
            self.use_nnue = False

        self.pawn_table = np.array([
             0,  0,  0,  0,  0,  0,  0,  0,
            50, 50, 50, 50, 50, 50, 50, 50,
            10, 10, 20, 30, 30, 20, 10, 10,
             5,  5, 10, 25, 25, 10,  5,  5,
             0,  0,  0, 20, 20,  0,  0,  0,
             5, -5,-10,  0,  0,-10, -5,  5,
             5, 10, 10,-20,-20, 10, 10,  5,
             0,  0,  0,  0,  0,  0,  0,  0
        ], dtype=np.float32)
        self.knight_table = np.array([
            -50,-40,-30,-30,-30,-30,-40,-50,
            -40,-20,  0,  5,  5,  0,-20,-40,
            -30,  5, 10, 15, 15, 10,  5,-30,
            -30,  0, 15, 20, 20, 15,  0,-30,
            -30,  5, 15, 20, 20, 15,  5,-30,
            -30,  0, 10, 15, 15, 10,  0,-30,
            -40,-20,  0,  0,  0,  0,-20,-40,
            -50,-40,-30,-30,-30,-30,-40,-50
        ], dtype=np.float32)
        self.bishop_table = np.array([
            -20,-10,-10,-10,-10,-10,-10,-20,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -10,  0,  5, 10, 10,  5,  0,-10,
            -10,  5,  5, 10, 10,  5,  5,-10,
            -10,  0, 10, 10, 10, 10,  0,-10,
            -10, 10, 10, 10, 10, 10, 10,-10,
            -10,  5,  0,  0,  0,  0,  5,-10,
            -20,-10,-10,-10,-10,-10,-10,-20
        ], dtype=np.float32)
        self.rook_table = np.array([
             0,  0,  0,  0,  0,  0,  0,  0,
             5, 10, 10, 10, 10, 10, 10,  5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
             0,  0,  0,  5,  5,  0,  0,  0
        ], dtype=np.float32)
        self.queen_table = np.array([
            -20,-10,-10, -5, -5,-10,-10,-20,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -10,  0,  5,  5,  5,  5,  0,-10,
             -5,  0,  5,  5,  5,  5,  0, -5,
              0,  0,  5,  5,  5,  5,  0, -5,
            -10,  5,  5,  5,  5,  5,  0,-10,
            -10,  0,  5,  0,  0,  0,  0,-10,
            -20,-10,-10, -5, -5,-10,-10,-20
        ], dtype=np.float32)
        self.king_table_middle = np.array([
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -20,-30,-30,-40,-40,-30,-30,-20,
            -10,-20,-20,-20,-20,-20,-20,-10,
             10, 10,  0,  0,  0,  0, 10, 10,
             20, 30, 10,  0,  0, 10, 30, 20
        ], dtype=np.float32)
        self.king_table_endgame = np.array([
            -50,-40,-30,-20,-20,-30,-40,-50,
            -40,-30,-20,-10,-10,-20,-30,-40,
            -30,-20,-10,  0,  0,-10,-20,-30,
            -20,-10,  0, 10, 10,  0,-10,-20,
            -20,-10,  0, 10, 10,  0,-10,-20,
            -30,-20,-10,  0,  0,-10,-20,-30,
            -40,-30,-20,-10,-10,-20,-30,-40,
            -50,-40,-30,-20,-20,-30,-40,-50
        ], dtype=np.float32)

        self.pawn_structure_table = defaultdict(lambda: (0, {chess.WHITE: set(), chess.BLACK: set()}))
        self.pawn_files = {color: [[] for _ in range(8)] for color in [chess.WHITE, chess.BLACK]}
        for square in chess.SQUARES:
            piece = self.board.piece_at(square)
            if piece and piece.piece_type == chess.PAWN:
                file = chess.square_file(square)
                self.pawn_files[piece.color][file].append(square)

    def get_total_material(self):
        total = 0
        for square in chess.SQUARES:
            piece = self.board.piece_at(square)
            if piece and piece.piece_type != chess.KING:
                total += self.piece_values[piece.piece_type]
        return total

    def evaluate_pawn_structure(self):
        pawn_hash = chess.polyglot.zobrist_hash(self.board)
        if pawn_hash in self.pawn_structure_table:
            return self.pawn_structure_table[pawn_hash]

        pawn_structure_score = 0
        isolated_pawn_penalty = 0
        doubled_pawn_penalty = 0
        passed_pawn_bonus = 0
        pawn_chain_bonus = 0
        backward_pawn_penalty = 0
        isolated_advanced_pawn_penalty = 0
        passed_pawns = {chess.WHITE: set(), chess.BLACK: set()}
        total_material = self.get_total_material()

        for file in range(8):
            white_pawns = self.pawn_files[chess.WHITE][file]
            black_pawns = self.pawn_files[chess.BLACK][file]

            if white_pawns:
                has_neighbor = (file > 0 and self.pawn_files[chess.WHITE][file - 1]) or \
                              (file < 7 and self.pawn_files[chess.WHITE][file + 1])
                if not has_neighbor:
                    isolated_pawn_penalty -= 10 * len(white_pawns)
                    # Phạt thêm nếu tốt cô lập ở vị trí tiến xa (dễ bị tấn công)
                    for square in white_pawns:
                        rank = chess.square_rank(square)
                        if rank >= 4:  # Tốt ở nửa bàn cờ đối phương
                            attackers = len(self.board.attackers(chess.BLACK, square))
                            defenders = len(self.board.attackers(chess.WHITE, square))
                            if attackers > defenders:
                                isolated_advanced_pawn_penalty -= 100  # Phạt nặng

            if black_pawns:
                has_neighbor = (file > 0 and self.pawn_files[chess.BLACK][file - 1]) or \
                              (file < 7 and self.pawn_files[chess.BLACK][file + 1])
                if not has_neighbor:
                    isolated_pawn_penalty += 10 * len(black_pawns)
                    for square in black_pawns:
                        rank = chess.square_rank(square)
                        if rank <= 3:
                            attackers = len(self.board.attackers(chess.WHITE, square))
                            defenders = len(self.board.attackers(chess.BLACK, square))
                            if attackers > defenders:
                                isolated_advanced_pawn_penalty += 100

            if len(white_pawns) > 1:
                doubled_pawn_penalty -= 5 * (len(white_pawns) - 1)
            if len(black_pawns) > 1:
                doubled_pawn_penalty += 5 * (len(black_pawns) - 1)

            for square in white_pawns:
                rank = chess.square_rank(square)
                is_passed = True
                for r in range(rank + 1, 8):
                    s = chess.square(file, r)
                    other_piece = self.board.piece_at(s)
                    if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == chess.BLACK:
                        is_passed = False
                        break
                if is_passed:
                    bonus = rank * 20 if total_material <= 1500 else rank * 15
                    if rank >= 6:
                        bonus += 70
                    king_square = self.board.king(chess.WHITE)
                    if king_square:
                        distance = chess.square_distance(square, king_square)
                        bonus += (8 - distance) * 5
                    passed_pawn_bonus += bonus
                    passed_pawns[chess.WHITE].add(square)

            for square in black_pawns:
                rank = chess.square_rank(square)
                is_passed = True
                for r in range(0, rank):
                    s = chess.square(file, r)
                    other_piece = self.board.piece_at(s)
                    if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == chess.WHITE:
                        is_passed = False
                        break
                if is_passed:
                    bonus = (7 - rank) * 20 if total_material <= 1500 else (7 - rank) * 15
                    if rank <= 1:
                        bonus += 70
                    king_square = self.board.king(chess.BLACK)
                    if king_square:
                        distance = chess.square_distance(square, king_square)
                        bonus += (8 - distance) * 5
                    passed_pawn_bonus -= bonus
                    passed_pawns[chess.BLACK].add(square)

            white_ranks = sorted([chess.square_rank(sq) for sq in white_pawns])
            black_ranks = sorted([chess.square_rank(sq) for sq in black_pawns])
            for i in range(len(white_ranks) - 1):
                if white_ranks[i + 1] == white_ranks[i] + 1 and chess.square_file(chess.square(file, white_ranks[i])) in [file - 1, file + 1]:
                    pawn_chain_bonus += 10
            for i in range(len(black_ranks) - 1):
                if black_ranks[i + 1] == black_ranks[i] - 1 and chess.square_file(chess.square(file, black_ranks[i])) in [file - 1, file + 1]:
                    pawn_chain_bonus -= 10

            for square in white_pawns:
                rank = chess.square_rank(square)
                if rank < 5 and not any(self.board.piece_at(chess.square(f, r)) and
                                        self.board.piece_at(chess.square(f, r)).piece_type == chess.PAWN and
                                        self.board.piece_at(chess.square(f, r)).color == chess.WHITE
                                        for f in [file - 1, file + 1] for r in range(rank, 8)):
                    backward_pawn_penalty -= 5
            for square in black_pawns:
                rank = chess.square_rank(square)
                if rank > 2 and not any(self.board.piece_at(chess.square(f, r)) and
                                        self.board.piece_at(chess.square(f, r)).piece_type == chess.PAWN and
                                        self.board.piece_at(chess.square(f, r)).color == chess.BLACK
                                        for f in [file - 1, file + 1] for r in range(0, rank)):
                    backward_pawn_penalty += 5

        pawn_structure_score = isolated_pawn_penalty + doubled_pawn_penalty + passed_pawn_bonus + pawn_chain_bonus + backward_pawn_penalty + isolated_advanced_pawn_penalty
        self.pawn_structure_table[pawn_hash] = (pawn_structure_score, passed_pawns)
        return pawn_structure_score, passed_pawns

    def evaluate_king_safety(self, color, piece_map, total_material):
        king_square = self.board.king(color)
        if king_square is None:
            return 0

        safety_score = 0
        king_rank = chess.square_rank(king_square)
        king_file = chess.square_file(king_square)

        if total_material > 1500 and 2 <= king_file <= 5 and 2 <= king_rank <= 5:
            safety_score -= 100

        pawn_shield_bonus = 0
        pawn_shield_squares = []
        if color == chess.WHITE:
            if 0 <= king_file <= 2:
                pawn_shield_squares = [chess.square(king_file + i, king_rank + 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]
            elif 5 <= king_file <= 7:
                pawn_shield_squares = [chess.square(king_file + i, king_rank + 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]
        else:
            if 0 <= king_file <= 2:
                pawn_shield_squares = [chess.square(king_file + i, king_rank - 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]
            elif 5 <= king_file <= 7:
                pawn_shield_squares = [chess.square(king_file + i, king_rank - 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]

        for square in pawn_shield_squares:
            piece = piece_map.get(square)
            if piece and piece.piece_type == chess.PAWN and piece.color == color:
                pawn_shield_bonus += 30

        attack_units = 0
        attackers = self.board.attackers(not color, king_square)
        for attacker_square in attackers:
            attacker = piece_map.get(attacker_square)
            if attacker:
                if attacker.piece_type == chess.PAWN:
                    attack_units += 1
                elif attacker.piece_type in [chess.KNIGHT, chess.BISHOP]:
                    attack_units += 3
                elif attacker.piece_type == chess.ROOK:
                    attack_units += 5
                elif attacker.piece_type == chess.QUEEN:
                    attack_units += 8

        open_file_penalty = 0
        for f in range(max(0, king_file - 1), min(8, king_file + 2)):
            is_open = True
            for r in range(8):
                s = chess.square(f, r)
                piece = piece_map.get(s)
                if piece and piece.piece_type == chess.PAWN:
                    is_open = False
                    break
            if is_open:
                open_file_penalty -= 15

        pawn_structure_weakness = 0
        if color == chess.WHITE:
            g_file = 6
            h_file = 7
            if not any(piece_map.get(chess.square(g_file, r)) and
                       piece_map.get(chess.square(g_file, r)).piece_type == chess.PAWN and
                       piece_map.get(chess.square(g_file, r)).color == chess.WHITE for r in range(8)):
                pawn_structure_weakness -= 50
            if not any(piece_map.get(chess.square(h_file, r)) and
                       piece_map.get(chess.square(h_file, r)).piece_type == chess.PAWN and
                       piece_map.get(chess.square(h_file, r)).color == chess.WHITE for r in range(8)):
                pawn_structure_weakness -= 50
        else:
            g_file = 6
            h_file = 7
            if not any(piece_map.get(chess.square(g_file, r)) and
                       piece_map.get(chess.square(g_file, r)).piece_type == chess.PAWN and
                       piece_map.get(chess.square(g_file, r)).color == chess.BLACK for r in range(8)):
                pawn_structure_weakness += 50
            if not any(piece_map.get(chess.square(h_file, r)) and
                       piece_map.get(chess.square(h_file, r)).piece_type == chess.PAWN and
                       piece_map.get(chess.square(h_file, r)).color == chess.BLACK for r in range(8)):
                pawn_structure_weakness += 50

        exposure_penalty = 0
        original_turn = self.board.turn
        self.board.turn = not color
        for move in self.board.legal_moves:
            if self.board.gives_check(move):
                self.board.push(move)
                if self.board.king(color) == king_square:
                    exposure_penalty -= 200
                self.board.pop()
        self.board.turn = original_turn

        king_moved_early_penalty = 0
        if len(self.board.move_stack) < 10 and total_material > 1500:
            if (color == chess.WHITE and king_square != chess.E1) or \
               (color == chess.BLACK and king_square != chess.E8):
                if not ((color == chess.WHITE and king_square in [chess.G1, chess.C1]) or \
                        (color == chess.BLACK and king_square in [chess.G8, chess.C8])):
                    king_moved_early_penalty -= 200

        castling_delay_penalty = 0
        if len(self.board.move_stack) < 10 and total_material > 1500:
            if not (color == chess.WHITE and (king_square in [chess.G1, chess.C1])) and \
               not (color == chess.BLACK and (king_square in [chess.G8, chess.C8])):
                knights_developed = 0
                bishops_developed = 0
                for square in chess.SQUARES:
                    piece = piece_map.get(square)
                    if piece and piece.color == color:
                        rank = chess.square_rank(square)
                        if piece.piece_type == chess.KNIGHT:
                            if (color == chess.WHITE and rank > 1) or (color == chess.BLACK and rank < 6):
                                knights_developed += 1
                        if piece.piece_type == chess.BISHOP:
                            if (color == chess.WHITE and rank > 1) or (color == chess.BLACK and rank < 6):
                                bishops_developed += 1
                if knights_developed + bishops_developed >= 2:
                    castling_delay_penalty -= 150

        safety_score -= attack_units * 5
        safety_score += pawn_shield_bonus
        safety_score += open_file_penalty
        safety_score += pawn_structure_weakness
        safety_score += exposure_penalty
        safety_score += king_moved_early_penalty
        safety_score += castling_delay_penalty
        if self.board.has_castling_rights(color):
            safety_score += 75
        if (color == chess.WHITE and (king_square in [chess.G1, chess.C1])) or \
           (color == chess.BLACK and (king_square in [chess.G8, chess.C8])):
            safety_score += 120

        return safety_score

    def evaluate_threatened_pieces(self, color, piece_map):
        threat_score = 0
        original_turn = self.board.turn
        self.board.turn = not color

        for square in chess.SQUARES:
            piece = piece_map.get(square)
            if piece and piece.color == color and piece.piece_type != chess.KING:
                attackers = self.board.attackers(not color, square)
                if attackers:
                    min_attacker_value = min(self.piece_values[piece_map.get(s).piece_type] for s in attackers)
                    defenders = self.board.attackers(color, square)
                    defender_count = len(defenders)
                    can_capture = False
                    for move in self.board.legal_moves:
                        if move.to_square == square:
                            can_capture = True
                            # Kiểm tra nếu nước đi dẫn đến mất quân lớn (như hậu)
                            self.board.push(move)
                            for next_move in self.board.legal_moves:
                                captured_piece = self.board.piece_at(next_move.to_square)
                                if captured_piece and captured_piece.piece_type == chess.QUEEN:
                                    threat_score -= 500  # Phạt nặng nếu mất hậu
                                    self.board.pop()
                                    return threat_score
                            self.board.pop()
                            break
                    if can_capture and (defender_count == 0 or (min_attacker_value < self.piece_values[piece.piece_type] and defender_count <= 1)):
                        penalty = self.piece_values[piece.piece_type] * 1.0
                        threat_score -= penalty

        self.board.turn = original_turn
        return threat_score

    def evaluate_exchange_risks(self, color, piece_map):
        exchange_score = 0
        original_turn = self.board.turn
        self.board.turn = not color

        for square in chess.SQUARES:
            piece = piece_map.get(square)
            if piece and piece.color == color and piece.piece_type != chess.KING:
                attackers = self.board.attackers(not color, square)
                if attackers:
                    for attacker_square in attackers:
                        attacker = piece_map.get(attacker_square)
                        if attacker:
                            attacker_value = self.piece_values[attacker.piece_type]
                            piece_value = self.piece_values[piece.piece_type]
                            if attacker_value < piece_value:
                                can_capture = False
                                for move in self.board.legal_moves:
                                    if move.to_square == square and move.from_square == attacker_square:
                                        can_capture = True
                                        break
                                if can_capture:
                                    exchange_loss = piece_value - attacker_value
                                    exchange_score -= exchange_loss

        self.board.turn = original_turn
        return exchange_score

    def evaluate_outposts(self, color, piece_map):
        outpost_score = 0
        outpost_squares = [chess.D5, chess.E5, chess.D4, chess.E4] if color == chess.WHITE else [chess.D4, chess.E4, chess.D5, chess.E5]
        for square in outpost_squares:
            piece = piece_map.get(square)
            if piece and piece.color == color and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                protected = False
                pawn_files = [chess.square_file(square) - 1, chess.square_file(square) + 1]
                for f in pawn_files:
                    if 0 <= f <= 7:
                        for r in range(8):
                            s = chess.square(f, r)
                            p = piece_map.get(s)
                            if p and p.piece_type == chess.PAWN and p.color == color:
                                protected = True
                                break
                if protected:
                    outpost_score += 20 if piece.piece_type == chess.KNIGHT else 15
        return outpost_score

    def evaluate_center_control_loss(self, color):
        center_control_loss = 0
        center_squares = [chess.D5, chess.E5] if color == chess.WHITE else [chess.D4, chess.E4]
        for square in center_squares:
            piece = self.board.piece_at(square)
            if not piece or (piece.piece_type != chess.PAWN or piece.color != color):
                opponent_attackers = len(self.board.attackers(not color, square))
                if opponent_attackers > 0:
                    center_control_loss -= 100
        return center_control_loss

    def evaluate_development_delay(self, color, piece_map):
        development_delay_penalty = 0
        passive_position_penalty = 0
        undeveloped_piece_penalty = 0
        early_heavy_piece_penalty = 0
        if len(self.board.move_stack) < 10:
            knights_developed = 0
            bishops_developed = 0
            undeveloped_knights = 0
            undeveloped_bishops = 0
            for square in chess.SQUARES:
                piece = piece_map.get(square)
                if piece and piece.color == color:
                    rank = chess.square_rank(square)
                    if piece.piece_type == chess.KNIGHT:
                        if (color == chess.WHITE and rank > 1) or (color == chess.BLACK and rank < 6):
                            knights_developed += 1
                        elif (color == chess.WHITE and rank == 0) or (color == chess.BLACK and rank == 7):
                            passive_position_penalty -= 200  # Tăng phạt
                        if (color == chess.WHITE and square in [chess.G1, chess.B1]) or \
                           (color == chess.BLACK and square in [chess.G8, chess.B8]):
                            undeveloped_knights += 1
                    if piece.piece_type == chess.BISHOP:
                        if (color == chess.WHITE and rank > 1) or (color == chess.BLACK and rank < 6):
                            bishops_developed += 1
                        elif (color == chess.WHITE and rank == 0) or (color == chess.BLACK and rank == 7):
                            passive_position_penalty -= 200  # Tăng phạt
                        if (color == chess.WHITE and square in [chess.C1, chess.F1]) or \
                           (color == chess.BLACK and square in [chess.C8, chess.F8]):
                            undeveloped_bishops += 1
                    if piece.piece_type in [chess.ROOK, chess.QUEEN]:
                        if (color == chess.WHITE and square not in [chess.A1, chess.D1]) or \
                           (color == chess.BLACK and square not in [chess.A8, chess.D8]):
                            if knights_developed + bishops_developed < 2:
                                early_heavy_piece_penalty -= 300  # Tăng phạt

            if knights_developed < 2:
                development_delay_penalty -= (2 - knights_developed) * 150
            if bishops_developed < 2:
                development_delay_penalty -= (2 - bishops_developed) * 150
            undeveloped_piece_penalty -= (undeveloped_knights + undeveloped_bishops) * 50
        return development_delay_penalty + passive_position_penalty + undeveloped_piece_penalty + early_heavy_piece_penalty

    def evaluate_board(self):
        if self.use_nnue:
            return self.nnue.evaluate(self.board)

        if self.board.is_checkmate():
            return -float('inf') if self.board.turn == chess.WHITE else float('inf')
        if self.board.is_stalemate() or self.board.is_insufficient_material():
            return 0

        if self.board.is_check():
            check_bonus = 80 if self.board.turn == chess.BLACK else -80
        else:
            check_bonus = 0

        material_score = 0
        total_material = 0
        for square in chess.SQUARES:
            piece = self.board.piece_at(square)
            if piece:
                value = self.piece_values[piece.piece_type]
                if piece.piece_type != chess.KING:
                    total_material += value
                material_score += value if piece.color == chess.WHITE else -value

        game_phase = min(1.0, max(0.0, (total_material - 1000) / (4000 - 1000)))

        piece_map = self.board.piece_map()

        position_score = 0
        center_control_score = 0
        king_safety_score = 0
        pawn_structure_score, passed_pawns = self.evaluate_pawn_structure()
        development_score = 0
        mobility_score = 0
        bishop_pair_bonus = 0
        rook_open_file_bonus = 0
        outpost_score = 0
        threat_score = 0
        exchange_score = 0
        center_loss_score = 0
        development_delay_score = 0
        active_position_bonus = 0

        white_bishops = 0
        black_bishops = 0
        white_developed_pieces = 0
        black_developed_pieces = 0

        for square in chess.SQUARES:
            piece = piece_map.get(square)
            if not piece:
                continue

            if piece.piece_type == chess.BISHOP:
                if piece.color == chess.WHITE:
                    white_bishops += 1
                else:
                    black_bishops += 1

            table_idx = square if piece.color == chess.WHITE else 63 - square
            if piece.piece_type == chess.PAWN:
                position_score += self.pawn_table[table_idx] * (1 if piece.color == chess.WHITE else -1)
            elif piece.piece_type == chess.KNIGHT:
                position_score += self.knight_table[table_idx] * (1 if piece.color == chess.WHITE else -1)
                if square in [chess.D4, chess.E4, chess.D5, chess.E5]:
                    active_position_bonus += 50 if piece.color == chess.WHITE else -50
            elif piece.piece_type == chess.BISHOP:
                position_score += self.bishop_table[table_idx] * (1 if piece.color == chess.WHITE else -1)
                if square in [chess.D4, chess.E4, chess.D5, chess.E5]:
                    active_position_bonus += 50 if piece.color == chess.WHITE else -50
            elif piece.piece_type == chess.ROOK:
                position_score += self.rook_table[table_idx] * (1 if piece.color == chess.WHITE else -1)
            elif piece.piece_type == chess.QUEEN:
                position_score += self.queen_table[table_idx] * (1 if piece.color == chess.WHITE else -1)
            elif piece.piece_type == chess.KING:
                if total_material > 1500:
                    position_score += self.king_table_middle[table_idx] * (1 if piece.color == chess.WHITE else -1)
                else:
                    position_score += self.king_table_endgame[table_idx] * (1 if piece.color == chess.WHITE else -1)

            if len(self.board.move_stack) < 10 and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                rank = chess.square_rank(square)
                if piece.color == chess.WHITE and rank > 1:
                    white_developed_pieces += 1
                elif piece.color == chess.BLACK and rank < 6:
                    black_developed_pieces += 1

            if piece.piece_type == chess.ROOK:
                file = chess.square_file(square)
                is_open = True
                for r in range(8):
                    s = chess.square(file, r)
                    if s != square:
                        other_piece = piece_map.get(s)
                        if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == piece.color:
                            is_open = False
                            break
                if is_open:
                    rook_open_file_bonus += 20 if piece.color == chess.WHITE else -20

        if white_bishops >= 2:
            bishop_pair_bonus += 30
        if black_bishops >= 2:
            bishop_pair_bonus -= 30

        center_squares = [chess.D4, chess.E4, chess.D5, chess.E5]
        for square in center_squares:
            piece = piece_map.get(square)
            if piece:
                if piece.piece_type == chess.PAWN:
                    center_control_score += 20 if piece.color == chess.WHITE else -20
                else:
                    center_control_score += 10 if piece.color == chess.WHITE else -10

        if len(self.board.move_stack) < 10:
            development_score += white_developed_pieces * 75  # Tăng thưởng
            development_score -= black_developed_pieces * 75

        original_turn = self.board.turn
        self.board.turn = chess.WHITE
        white_mobility = len(list(self.board.legal_moves))
        self.board.turn = chess.BLACK
        black_mobility = len(list(self.board.legal_moves))
        self.board.turn = original_turn
        mobility_score += (white_mobility - black_mobility) * 5

        white_king_safety = self.evaluate_king_safety(chess.WHITE, piece_map, total_material)
        black_king_safety = self.evaluate_king_safety(chess.BLACK, piece_map, total_material)
        king_safety_score = white_king_safety - black_king_safety

        white_outpost_score = self.evaluate_outposts(chess.WHITE, piece_map)
        black_outpost_score = self.evaluate_outposts(chess.BLACK, piece_map)
        outpost_score = white_outpost_score - black_outpost_score

        white_threat_score = self.evaluate_threatened_pieces(chess.WHITE, piece_map)
        black_threat_score = self.evaluate_threatened_pieces(chess.BLACK, piece_map)
        threat_score = white_threat_score - black_threat_score

        white_exchange_score = self.evaluate_exchange_risks(chess.WHITE, piece_map)
        black_exchange_score = self.evaluate_exchange_risks(chess.BLACK, piece_map)
        exchange_score = white_exchange_score - black_exchange_score

        white_center_loss = self.evaluate_center_control_loss(chess.WHITE)
        black_center_loss = self.evaluate_center_control_loss(chess.BLACK)
        center_loss_score = white_center_loss - black_center_loss

        white_development_delay = self.evaluate_development_delay(chess.WHITE, piece_map)
        black_development_delay = self.evaluate_development_delay(chess.BLACK, piece_map)
        development_delay_score = white_development_delay - black_development_delay

        eval_score = (material_score +
                      position_score +
                      center_control_score +
                      king_safety_score +
                      pawn_structure_score +
                      development_score +
                      mobility_score +
                      bishop_pair_bonus +
                      rook_open_file_bonus +
                      outpost_score +
                      threat_score +
                      exchange_score +
                      center_loss_score +
                      development_delay_score +
                      active_position_bonus +
                      check_bonus)

        return eval_score