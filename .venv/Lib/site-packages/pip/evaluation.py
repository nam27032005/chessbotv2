import chess
from collections import defaultdict
from nnue import NNUE

class Evaluation:
    def __init__(self, board, piece_values, pawn_table_opening=None, pawn_table_middlegame=None, pawn_table_endgame=None,
                 knight_table=None, bishop_table=None, rook_table=None, queen_table=None, king_table_opening=None,
                 king_table_endgame=None, use_nnue=True):
        self.board = board
        self.piece_values = piece_values
        self.pawn_table_opening = pawn_table_opening or [[0] * 8 for _ in range(8)]
        self.pawn_table_middlegame = pawn_table_middlegame or [[0] * 8 for _ in range(8)]
        self.pawn_table_endgame = pawn_table_endgame or [[0] * 8 for _ in range(8)]
        self.knight_table = knight_table or [[0] * 8 for _ in range(8)]
        self.bishop_table = bishop_table or [[0] * 8 for _ in range(8)]
        self.rook_table = rook_table or [[0] * 8 for _ in range(8)]
        self.queen_table = queen_table or [[0] * 8 for _ in range(8)]
        self.king_table_opening = king_table_opening or [[0] * 8 for _ in range(8)]
        self.king_table_endgame = king_table_endgame or [[0] * 8 for _ in range(8)]
        self.pawn_structure_table = {}
        self.use_nnue = use_nnue
        if use_nnue:
            self.nnue = NNUE()
        self.material_score = 0
        self.total_material = 0
        self._initialize_material()

    def _initialize_material(self):
        self.material_score = 0
        self.total_material = 0
        for square in chess.SQUARES:
            piece = self.board.piece_at(square)
            if piece:
                value = self.piece_values[piece.piece_type]
                self.total_material += value
                if piece.color == chess.WHITE:
                    self.material_score += value
                else:
                    self.material_score -= value

    def get_total_material(self):
        return self.total_material

    def evaluate_pawn_structure(self):
        pawn_hash = chess.polyglot.zobrist_hash(self.board)
        if pawn_hash in self.pawn_structure_table:
            return self.pawn_structure_table[pawn_hash][0]

        pawn_structure_score = 0
        isolated_pawn_penalty = 0
        doubled_pawn_penalty = 0
        passed_pawn_bonus = 0
        passed_pawns = {chess.WHITE: set(), chess.BLACK: set()}

        for square in chess.SQUARES:
            piece = self.board.piece_at(square)
            if piece and piece.piece_type == chess.PAWN:
                file = chess.square_file(square)
                rank = chess.square_rank(square)

                left_file = file - 1 if file > 0 else None
                right_file = file + 1 if file < 7 else None
                has_neighbor = False
                for s in chess.SQUARES:
                    if s != square and chess.square_file(s) in [left_file, right_file]:
                        other_piece = self.board.piece_at(s)
                        if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == piece.color:
                            has_neighbor = True
                            break
                if not has_neighbor:
                    if piece.color == chess.WHITE:
                        isolated_pawn_penalty -= 0.5
                    else:
                        isolated_pawn_penalty += 0.5

                for s in chess.SQUARES:
                    if s != square and chess.square_file(s) == file:
                        other_piece = self.board.piece_at(s)
                        if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == piece.color:
                            if piece.color == chess.WHITE:
                                doubled_pawn_penalty -= 0.3
                            else:
                                doubled_pawn_penalty += 0.3
                            break

                is_passed = True
                for r in range(rank + 1 if piece.color == chess.WHITE else 0,
                               8 if piece.color == chess.WHITE else rank):
                    s = chess.square(file, r)
                    other_piece = self.board.piece_at(s)
                    if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color != piece.color:
                        is_passed = False
                        break
                if is_passed:
                    bonus = (rank if piece.color == chess.WHITE else 7 - rank) * 1.0
                    if (piece.color == chess.WHITE and rank >= 6) or (piece.color == chess.BLACK and rank <= 1):
                        bonus *= 3
                    if piece.color == chess.WHITE:
                        passed_pawn_bonus += bonus
                        passed_pawns[chess.WHITE].add(square)
                    else:
                        passed_pawn_bonus -= bonus
                        passed_pawns[chess.BLACK].add(square)

        pawn_structure_score = isolated_pawn_penalty + doubled_pawn_penalty + passed_pawn_bonus
        self.pawn_structure_table[pawn_hash] = (pawn_structure_score, passed_pawns)
        return pawn_structure_score

    def evaluate_king_safety(self, color, piece_map, total_material):
        king_square = self.board.king(color)
        if king_square is None:
            return 0

        safety_score = 0
        king_rank = chess.square_rank(king_square)
        king_file = chess.square_file(king_square)

        attack_units = 0
        attackers = self.board.attackers(not color, king_square)
        for attacker_square in attackers:
            attacker = piece_map.get(attacker_square)
            if attacker:
                if attacker.piece_type == chess.PAWN:
                    attack_units += 1
                elif attacker.piece_type in [chess.KNIGHT, chess.BISHOP]:
                    attack_units += 2
                elif attacker.piece_type == chess.ROOK:
                    attack_units += 3
                elif attacker.piece_type == chess.QUEEN:
                    attack_units += 5

        pawn_shield_bonus = 0
        pawn_shield_squares = []
        if color == chess.WHITE:
            if 0 <= king_file <= 2:
                pawn_shield_squares = [chess.square(king_file + i, king_rank + 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]
            elif 5 <= king_file <= 7:
                pawn_shield_squares = [chess.square(king_file + i, king_rank + 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]
        else:
            if 0 <= king_file <= 2:
                pawn_shield_squares = [chess.square(king_file + i, king_rank - 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]
            elif 5 <= king_file <= 7:
                pawn_shield_squares = [chess.square(king_file + i, king_rank - 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]

        for square in pawn_shield_squares:
            piece = piece_map.get(square)
            if piece and piece.piece_type == chess.PAWN and piece.color == color:
                pawn_shield_bonus += 0.5

        if total_material > 3000 and 2 <= king_file <= 5:
            safety_score -= 2.0

        safety_score -= attack_units * 0.5
        safety_score += pawn_shield_bonus * 1.2
        if self.board.has_castling_rights(color):
            safety_score += 2.0

        return safety_score

    def evaluate_piece_safety(self, square, piece, piece_map):
        safety_penalty = 0
        attackers = self.board.attackers(not piece.color, square)
        if attackers:
            min_attacker_value = float('inf')
            for attacker_square in attackers:
                attacker = piece_map.get(attacker_square)
                if attacker:
                    attacker_value = self.piece_values[attacker.piece_type]
                    min_attacker_value = min(min_attacker_value, attacker_value)

            defenders = self.board.attackers(piece.color, square)
            min_defender_value = float('inf')
            if defenders:
                for defender_square in defenders:
                    defender = piece_map.get(defender_square)
                    if defender:
                        defender_value = self.piece_values[defender.piece_type]
                        min_defender_value = min(min_defender_value, defender_value)
            else:
                min_defender_value = float('inf')

            if min_attacker_value < min_defender_value:
                safety_penalty = self.piece_values[piece.piece_type] * 0.5

            for attacker_square in attackers:
                attacker = piece_map.get(attacker_square)
                if attacker and attacker.piece_type == chess.PAWN:
                    safety_penalty += 1.5

        return safety_penalty

    def evaluate_board(self):
        if self.use_nnue:
            return self.nnue.evaluate(self.board)

        zobrist_hash = chess.polyglot.zobrist_hash(self.board)
        if zobrist_hash in self.pawn_structure_table:
            score, depth, flag, _ = self.pawn_structure_table[zobrist_hash]
            if depth == 0 and flag == 0:
                return score

        for move in self.board.legal_moves:
            self.board.push(move)
            if self.board.is_checkmate():
                self.board.pop()
                score = float('inf') if self.board.turn == chess.BLACK else -float('inf')
                self.pawn_structure_table[zobrist_hash] = (score, 0, 0, None)
                return score
            self.board.pop()

        if self.board.is_checkmate():
            if self.board.turn == chess.WHITE:
                return -float('inf')
            else:
                return float('inf')
        if self.board.is_stalemate() or self.board.is_insufficient_material():
            return 0

        game_phase = min(1.0, max(0.0, (self.total_material - 1500) / (4000 - 1500)))

        piece_map = self.board.piece_map()

        material_score = self.material_score
        position_score_opening = 0
        position_score_endgame = 0
        center_control_score = 0
        king_safety_score = 0
        pawn_structure_score = self.evaluate_pawn_structure()
        development_score = 0
        mobility_score = 0
        threat_score = 0
        bishop_pair_bonus = 0
        rook_open_file_bonus = 0
        passed_pawn_bonus = 0
        king_activity_score = 0
        outpost_score = 0
        diagonal_control_score = 0
        pinned_piece_penalty = 0
        center_pawn_bonus = 0
        passive_move_penalty = 0
        castling_bonus = 0
        exposed_piece_penalty = 0
        piece_safety_penalty = 0
        undeveloped_piece_penalty = 0
        castling_preparation_bonus = 0
        ineffective_move_penalty = 0
        piece_coordination_bonus = 0
        center_attack_bonus = 0
        tactical_threat_bonus = 0

        white_bishops = 0
        black_bishops = 0
        white_developed_pieces = 0
        black_developed_pieces = 0
        white_center_control = 0
        black_center_control = 0
        white_knights = 0
        black_knights = 0

        for square in chess.SQUARES:
            piece = piece_map.get(square)
            if not piece:
                continue

            if piece.piece_type == chess.BISHOP:
                if piece.color == chess.WHITE:
                    white_bishops += 1
                else:
                    black_bishops += 1
            elif piece.piece_type == chess.KNIGHT:
                if piece.color == chess.WHITE:
                    white_knights += 1
                else:
                    black_knights += 1

            rank = chess.square_rank(square)
            file = chess.square_file(square)
            if piece.color == chess.BLACK:
                rank = 7 - rank

            piece_position_score_opening = 0
            piece_position_score_endgame = 0
            if piece.piece_type == chess.PAWN:
                piece_position_score_opening = self.pawn_table_opening[rank][file]
                piece_position_score_endgame = self.pawn_table_endgame[rank][file]
            elif piece.piece_type == chess.KNIGHT:
                piece_position_score_opening = self.knight_table[rank][file]
                piece_position_score_endgame = self.knight_table[rank][file]
            elif piece.piece_type == chess.BISHOP:
                piece_position_score_opening = self.bishop_table[rank][file]
                piece_position_score_endgame = self.bishop_table[rank][file]
            elif piece.piece_type == chess.ROOK:
                piece_position_score_opening = self.rook_table[rank][file]
                piece_position_score_endgame = self.rook_table[rank][file]
            elif piece.piece_type == chess.QUEEN:
                piece_position_score_opening = self.queen_table[rank][file]
                piece_position_score_endgame = self.queen_table[rank][file]
            elif piece.piece_type == chess.KING:
                piece_position_score_opening = self.king_table_opening[rank][file]
                piece_position_score_endgame = self.king_table_endgame[rank][file]

            if piece.color == chess.WHITE:
                position_score_opening += piece_position_score_opening
                position_score_endgame += piece_position_score_endgame
            else:
                position_score_opening -= piece_position_score_opening
                position_score_endgame -= piece_position_score_endgame

            attackers = self.board.attackers(not piece.color, square)
            defenders = self.board.attackers(piece.color, square)
            if attackers:
                min_attacker_value = float('inf')
                for attacker_square in attackers:
                    attacker = piece_map.get(attacker_square)
                    if attacker:
                        attacker_value = self.piece_values[attacker.piece_type]
                        min_attacker_value = min(min_attacker_value, attacker_value)
                min_defender_value = float('inf')
                if defenders:
                    for defender_square in defenders:
                        defender = piece_map.get(defender_square)
                        if defender:
                            defender_value = self.piece_values[defender.piece_type]
                            min_defender_value = min(min_defender_value, defender_value)
                else:
                    min_defender_value = float('inf')

                if min_attacker_value < min_defender_value:
                    threat_value = self.piece_values[piece.piece_type] * 1.0
                    if piece.color == chess.WHITE:
                        threat_score -= threat_value
                    else:
                        threat_score += threat_value

                if len(self.board.move_stack) < 10 and piece.piece_type == chess.BISHOP:
                    actual_rank = chess.square_rank(square)
                    if piece.color == chess.WHITE and actual_rank >= 5:
                        exposed_piece_penalty -= 2.5
                    elif piece.color == chess.BLACK and actual_rank <= 2:
                        exposed_piece_penalty += 2.5

            safety_penalty = self.evaluate_piece_safety(square, piece, piece_map)
            if piece.color == chess.WHITE:
                piece_safety_penalty -= safety_penalty
            else:
                piece_safety_penalty += safety_penalty

            if piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]:
                self.board.push(chess.Move.null())
                self.board.turn = piece.color
                legal_moves = len(list(self.board.legal_moves))
                self.board.pop()
                mobility = legal_moves * (0.07 if self.total_material > 3000 else 0.2)
                if piece.color == chess.WHITE:
                    mobility_score += mobility
                else:
                    mobility_score -= mobility

            if piece.piece_type == chess.ROOK:
                file = chess.square_file(square)
                is_open = True
                for r in range(8):
                    s = chess.square(file, r)
                    if s != square:
                        other_piece = piece_map.get(s)
                        if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == piece.color:
                            is_open = False
                            break
                if is_open:
                    if piece.color == chess.WHITE:
                        rook_open_file_bonus += 0.7
                    else:
                        rook_open_file_bonus -= 0.7

            if piece.piece_type in [chess.BISHOP, chess.QUEEN]:
                if abs(file - rank) == 0 or abs(file + rank - 7) == 0:
                    diagonal_bonus = 0.15 if self.total_material > 3000 else 0.4
                    if piece.color == chess.WHITE:
                        diagonal_control_score += diagonal_bonus
                    else:
                        diagonal_control_score -= diagonal_bonus

            if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                rank = chess.square_rank(square)
                if piece.color == chess.WHITE and rank >= 4:
                    protected = False
                    for s in chess.SQUARES:
                        if chess.square_file(s) in [file - 1, file + 1] and chess.square_rank(s) < rank:
                            other_piece = piece_map.get(s)
                            if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == chess.WHITE:
                                protected = True
                                break
                    if protected:
                        outpost_bonus = 0.4 if self.total_material > 3000 else 0.7
                        outpost_score += outpost_bonus
                elif piece.color == chess.BLACK and rank <= 3:
                    protected = False
                    for s in chess.SQUARES:
                        if chess.square_file(s) in [file - 1, file + 1] and chess.square_rank(s) > rank:
                            other_piece = piece_map.get(s)
                            if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == chess.BLACK:
                                protected = True
                                break
                    if protected:
                        outpost_bonus = 0.4 if self.total_material > 3000 else 0.7
                        outpost_score -= outpost_bonus

                if len(self.board.move_stack) < 10:
                    if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                        if piece.color == chess.WHITE and rank > 1:
                            white_developed_pieces += 1
                        elif piece.color == chess.BLACK and rank < 6:
                            black_developed_pieces += 1

            king_square = self.board.king(piece.color)
            if king_square is not None:
                pin = self.board.pin(not piece.color, square)
                if pin & (1 << king_square):
                    penalty = self.piece_values[piece.piece_type] * 0.3
                    if piece.color == chess.WHITE:
                        pinned_piece_penalty -= penalty
                    else:
                        pinned_piece_penalty += penalty

            if square in [chess.D4, chess.D5, chess.E4, chess.E5]:
                if piece.color == chess.WHITE:
                    white_center_control += 1
                else:
                    black_center_control += 1

        if white_bishops >= 2:
            bishop_pair_bonus += 0.7
        if black_bishops >= 2:
            bishop_pair_bonus -= 0.7

        center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]
        for square in center_squares:
            piece = piece_map.get(square)
            if piece:
                if piece.piece_type == chess.PAWN:
                    value = 2.5 if self.total_material > 3000 else 1.2
                else:
                    value = 0.7
                if piece.color == chess.WHITE:
                    center_control_score += value
                else:
                    center_control_score -= value

        white_king_safety = self.evaluate_king_safety(chess.WHITE, piece_map, self.total_material)
        black_king_safety = self.evaluate_king_safety(chess.BLACK, piece_map, self.total_material)
        king_safety_score = white_king_safety - black_king_safety

        if len(self.board.move_stack) < 10:
            development_score += white_developed_pieces * 5.0
            development_score -= black_developed_pieces * 5.0

            if white_developed_pieces > black_developed_pieces + 1:
                passive_move_penalty -= 5.0
            elif black_developed_pieces > white_developed_pieces + 1:
                passive_move_penalty += 5.0

            if white_center_control > black_center_control + 1:
                threat_score -= 5.0
            elif black_center_control > white_center_control + 1:
                threat_score += 5.0

        if len(self.board.move_stack) < 10:
            black_knights_developed = 0
            for square in [chess.G8, chess.F6]:
                piece = piece_map.get(square)
                if piece and piece.piece_type == chess.KNIGHT and piece.color == chess.BLACK:
                    black_knights_developed += 1
            if black_knights_developed < 1:
                undeveloped_piece_penalty += 4.0

            white_knights_developed = 0
            for square in [chess.G1, chess.F3]:
                piece = piece_map.get(square)
                if piece and piece.piece_type == chess.KNIGHT and piece.color == chess.WHITE:
                    white_knights_developed += 1
            if white_knights_developed < 1:
                undeveloped_piece_penalty -= 4.0

        if len(self.board.move_stack) < 10:
            if self.board.has_castling_rights(chess.BLACK):
                king_side_clear = True
                for square in [chess.F8, chess.G8]:
                    if piece_map.get(square):
                        king_side_clear = False
                        break
                if king_side_clear:
                    castling_preparation_bonus += 2.0

            if self.board.has_castling_rights(chess.WHITE):
                king_side_clear = True
                for square in [chess.F1, chess.G1]:
                    if piece_map.get(square):
                        king_side_clear = False
                        break
                if king_side_clear:
                    castling_preparation_bonus -= 2.0

        if len(self.board.move_stack) < 10 and self.board.move_stack:
            last_move = self.board.move_stack[-1]
            to_square = last_move.to_square
            piece = piece_map.get(to_square)
            if piece:
                attackers = self.board.attackers(not piece.color, to_square)
                if not attackers and piece.piece_type == chess.BISHOP:
                    if not (abs(chess.square_file(to_square) - chess.square_rank(to_square)) == 0 or
                            abs(chess.square_file(to_square) + chess.square_rank(to_square) - 7) == 0):
                        if piece.color == chess.WHITE:
                            ineffective_move_penalty -= 1.5
                        else:
                            ineffective_move_penalty += 1.5

        if len(self.board.move_stack) < 10:
            for square in center_squares:
                for color in [chess.WHITE, chess.BLACK]:
                    attackers = self.board.attackers(color, square)
                    knight_count = 0
                    bishop_count = 0
                    for attacker_square in attackers:
                        attacker = piece_map.get(attacker_square)
                        if attacker:
                            if attacker.piece_type == chess.KNIGHT:
                                knight_count += 1
                            elif attacker.piece_type == chess.BISHOP:
                                bishop_count += 1
                    if knight_count >= 1 and bishop_count >= 1:
                        if color == chess.WHITE:
                            piece_coordination_bonus += 1.0
                        else:
                            piece_coordination_bonus -= 1.0

        if len(self.board.move_stack) < 10:
            for square in center_squares:
                piece = piece_map.get(square)
                if piece and piece.piece_type == chess.PAWN:
                    attackers = self.board.attackers(not piece.color, square)
                    for attacker_square in attackers:
                        attacker = piece_map.get(attacker_square)
                        if attacker:
                            if piece.color == chess.WHITE:
                                center_attack_bonus -= 1.0
                            else:
                                center_attack_bonus += 1.0

        for square in chess.SQUARES:
            piece = piece_map.get(square)
            if piece:
                attackers = self.board.attackers(not piece.color, square)
                for attacker_square in attackers:
                    attacker = piece_map.get(attacker_square)
                    if attacker:
                        if piece.color == chess.WHITE:
                            tactical_threat_bonus -= 2.0
                        else:
                            tactical_threat_bonus += 2.0

        if self.total_material > 1500:
            for square in chess.SQUARES:
                piece = self.board.piece_at(square)
                if piece and piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]:
                    attackers = self.board.attackers(piece.color, square)
                    if len(attackers) >= 2:
                        coordination_bonus = 1.5 if piece.color == chess.WHITE else -1.5
                        piece_coordination_bonus += coordination_bonus

        if self.total_material <= 1500:
            _, passed_pawns = self.pawn_structure_table.get(chess.polyglot.zobrist_hash(self.board), (0, {chess.WHITE: set(), chess.BLACK: set()}))
            for color, pawns in passed_pawns.items():
                for square in pawns:
                    rank = chess.square_rank(square)
                    if color == chess.WHITE:
                        passed_pawn_bonus += (rank * 2.0)
                        if rank >= 6:
                            passed_pawn_bonus += 10.0
                    else:
                        passed_pawn_bonus -= ((7 - rank) * 2.0)
                        if rank <= 1:
                            passed_pawn_bonus -= 10.0

        if self.total_material <= 1500:
            for color in [chess.WHITE, chess.BLACK]:
                king_square = self.board.king(color)
                if king_square is not None:
                    self.board.push(chess.Move.null())
                    self.board.turn = color
                    king_mobility = len(list(self.board.legal_moves))
                    self.board.pop()
                    activity_bonus = king_mobility * 0.5
                    if color == chess.WHITE:
                        king_activity_score += activity_bonus
                    else:
                        king_activity_score -= activity_bonus

                    file = chess.square_file(king_square)
                    rank = chess.square_rank(king_square)
                    center_distance = max(abs(file - 3.5), abs(rank - 3.5))
                    center_bonus = (4 - center_distance) * 1.0
                    if color == chess.WHITE:
                        king_activity_score += center_bonus
                    else:
                        king_activity_score -= center_bonus

        position_score = position_score_opening * game_phase + position_score_endgame * (1 - game_phase)

        eval_score = (material_score + position_score + center_control_score +
                      king_safety_score + pawn_structure_score + development_score +
                      mobility_score + threat_score + bishop_pair_bonus + rook_open_file_bonus +
                      passed_pawn_bonus + king_activity_score + outpost_score +
                      diagonal_control_score + pinned_piece_penalty + center_pawn_bonus +
                      passive_move_penalty + castling_bonus + exposed_piece_penalty +
                      piece_safety_penalty + undeveloped_piece_penalty + castling_preparation_bonus +
                      ineffective_move_penalty + piece_coordination_bonus + center_attack_bonus +
                      tactical_threat_bonus)

        self.pawn_structure_table[zobrist_hash] = (eval_score, 0, 0, None)
        return eval_score