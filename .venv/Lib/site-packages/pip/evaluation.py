import chess
from collections import defaultdict  # Thêm import này để sửa lỗi NameError
import numpy as np


class Evaluation:
    def __init__(self, board, piece_values, pawn_table_opening=None, pawn_table_middlegame=None, pawn_table_endgame=None,
                 knight_table=None, bishop_table=None, rook_table=None, queen_table=None, king_table_opening=None,
                 king_table_endgame=None, use_nnue=True):
        self.board = board
        self.piece_values = piece_values
        self.use_nnue = use_nnue
        try:
            if use_nnue:
                from nnue import NNUE
                self.nnue = NNUE()
        except ImportError:
            self.use_nnue = False

        # Bảng giá trị vị trí (piece-square tables)
        self.pawn_table = [
             0,  0,  0,  0,  0,  0,  0,  0,
            50, 50, 50, 50, 50, 50, 50, 50,
            10, 10, 20, 30, 30, 20, 10, 10,
             5,  5, 10, 25, 25, 10,  5,  5,
             0,  0,  0, 20, 20,  0,  0,  0,
             5, -5,-10,  0,  0,-10, -5,  5,
             5, 10, 10,-20,-20, 10, 10,  5,
             0,  0,  0,  0,  0,  0,  0,  0
        ]
        self.knight_table = [
            -50,-40,-30,-30,-30,-30,-40,-50,
            -40,-20,  0,  5,  5,  0,-20,-40,
            -30,  5, 10, 15, 15, 10,  5,-30,
            -30,  0, 15, 20, 20, 15,  0,-30,
            -30,  5, 15, 20, 20, 15,  5,-30,
            -30,  0, 10, 15, 15, 10,  0,-30,
            -40,-20,  0,  0,  0,  0,-20,-40,
            -50,-40,-30,-30,-30,-30,-40,-50
        ]
        self.bishop_table = [
            -20,-10,-10,-10,-10,-10,-10,-20,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -10,  0,  5, 10, 10,  5,  0,-10,
            -10,  5,  5, 10, 10,  5,  5,-10,
            -10,  0, 10, 10, 10, 10,  0,-10,
            -10, 10, 10, 10, 10, 10, 10,-10,
            -10,  5,  0,  0,  0,  0,  5,-10,
            -20,-10,-10,-10,-10,-10,-10,-20
        ]
        self.rook_table = [
             0,  0,  0,  0,  0,  0,  0,  0,
             5, 10, 10, 10, 10, 10, 10,  5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
            -5,  0,  0,  0,  0,  0,  0, -5,
             0,  0,  0,  5,  5,  0,  0,  0
        ]
        self.queen_table = [
            -20,-10,-10, -5, -5,-10,-10,-20,
            -10,  0,  0,  0,  0,  0,  0,-10,
            -10,  0,  5,  5,  5,  5,  0,-10,
             -5,  0,  5,  5,  5,  5,  0, -5,
              0,  0,  5,  5,  5,  5,  0, -5,
            -10,  5,  5,  5,  5,  5,  0,-10,
            -10,  0,  5,  0,  0,  0,  0,-10,
            -20,-10,-10, -5, -5,-10,-10,-20
        ]
        self.king_table_middle = [
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -30,-40,-40,-50,-50,-40,-40,-30,
            -20,-30,-30,-40,-40,-30,-30,-20,
            -10,-20,-20,-20,-20,-20,-20,-10,
             10, 10,  0,  0,  0,  0, 10, 10,
             20, 30, 10,  0,  0, 10, 30, 20
        ]
        self.king_table_endgame = [
            -50,-40,-30,-20,-20,-30,-40,-50,
            -40,-30,-20,-10,-10,-20,-30,-40,
            -30,-20,-10,  0,  0,-10,-20,-30,
            -20,-10,  0, 10, 10,  0,-10,-20,
            -20,-10,  0, 10, 10,  0,-10,-20,
            -30,-20,-10,  0,  0,-10,-20,-30,
            -40,-30,-20,-10,-10,-20,-30,-40,
            -50,-40,-30,-20,-20,-30,-40,-50
        ]

        self.pawn_structure_table = defaultdict(lambda: (0, {chess.WHITE: set(), chess.BLACK: set()}))

    def get_total_material(self):
        total = 0
        for square in chess.SQUARES:
            piece = self.board.piece_at(square)
            if piece and piece.piece_type != chess.KING:
                total += self.piece_values[piece.piece_type]
        return total

    def evaluate_pawn_structure(self):
        pawn_hash = chess.polyglot.zobrist_hash(self.board)
        if pawn_hash in self.pawn_structure_table:
            return self.pawn_structure_table[pawn_hash]

        pawn_structure_score = 0
        isolated_pawn_penalty = 0
        doubled_pawn_penalty = 0
        passed_pawn_bonus = 0
        passed_pawns = {chess.WHITE: set(), chess.BLACK: set()}

        # Duyệt từng cột để kiểm tra cấu trúc tốt
        for file in range(8):
            white_pawns = []
            black_pawns = []
            for rank in range(8):
                square = chess.square(file, rank)
                piece = self.board.piece_at(square)
                if piece and piece.piece_type == chess.PAWN:
                    if piece.color == chess.WHITE:
                        white_pawns.append(square)
                    else:
                        black_pawns.append(square)

            # Phạt tốt cô lập
            if white_pawns:
                if file == 0:
                    has_neighbor = any(self.board.piece_at(chess.square(1, r)) and
                                      self.board.piece_at(chess.square(1, r)).piece_type == chess.PAWN and
                                      self.board.piece_at(chess.square(1, r)).color == chess.WHITE for r in range(8))
                elif file == 7:
                    has_neighbor = any(self.board.piece_at(chess.square(6, r)) and
                                      self.board.piece_at(chess.square(6, r)).piece_type == chess.PAWN and
                                      self.board.piece_at(chess.square(6, r)).color == chess.WHITE for r in range(8))
                else:
                    has_neighbor = (any(self.board.piece_at(chess.square(file - 1, r)) and
                                       self.board.piece_at(chess.square(file - 1, r)).piece_type == chess.PAWN and
                                       self.board.piece_at(chess.square(file - 1, r)).color == chess.WHITE for r in range(8)) or
                                   any(self.board.piece_at(chess.square(file + 1, r)) and
                                       self.board.piece_at(chess.square(file + 1, r)).piece_type == chess.PAWN and
                                       self.board.piece_at(chess.square(file + 1, r)).color == chess.WHITE for r in range(8)))
                if not has_neighbor:
                    isolated_pawn_penalty -= 15 * len(white_pawns)

            if black_pawns:
                if file == 0:
                    has_neighbor = any(self.board.piece_at(chess.square(1, r)) and
                                      self.board.piece_at(chess.square(1, r)).piece_type == chess.PAWN and
                                      self.board.piece_at(chess.square(1, r)).color == chess.BLACK for r in range(8))
                elif file == 7:
                    has_neighbor = any(self.board.piece_at(chess.square(6, r)) and
                                      self.board.piece_at(chess.square(6, r)).piece_type == chess.PAWN and
                                      self.board.piece_at(chess.square(6, r)).color == chess.BLACK for r in range(8))
                else:
                    has_neighbor = (any(self.board.piece_at(chess.square(file - 1, r)) and
                                       self.board.piece_at(chess.square(file - 1, r)).piece_type == chess.PAWN and
                                       self.board.piece_at(chess.square(file - 1, r)).color == chess.BLACK for r in range(8)) or
                                   any(self.board.piece_at(chess.square(file + 1, r)) and
                                       self.board.piece_at(chess.square(file + 1, r)).piece_type == chess.PAWN and
                                       self.board.piece_at(chess.square(file + 1, r)).color == chess.BLACK for r in range(8)))
                if not has_neighbor:
                    isolated_pawn_penalty += 15 * len(black_pawns)

            # Phạt tốt đôi
            if len(white_pawns) > 1:
                doubled_pawn_penalty -= 10 * (len(white_pawns) - 1)
            if len(black_pawns) > 1:
                doubled_pawn_penalty += 10 * (len(black_pawns) - 1)

            # Thưởng tốt thông
            for square in white_pawns:
                rank = chess.square_rank(square)
                is_passed = True
                for r in range(rank + 1, 8):
                    s = chess.square(file, r)
                    other_piece = self.board.piece_at(s)
                    if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == chess.BLACK:
                        is_passed = False
                        break
                if is_passed:
                    bonus = rank * 10
                    if rank >= 6:
                        bonus += 30
                    passed_pawn_bonus += bonus
                    passed_pawns[chess.WHITE].add(square)

            for square in black_pawns:
                rank = chess.square_rank(square)
                is_passed = True
                for r in range(0, rank):
                    s = chess.square(file, r)
                    other_piece = self.board.piece_at(s)
                    if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == chess.WHITE:
                        is_passed = False
                        break
                if is_passed:
                    bonus = (7 - rank) * 10
                    if rank <= 1:
                        bonus += 30
                    passed_pawn_bonus -= bonus
                    passed_pawns[chess.BLACK].add(square)

        pawn_structure_score = isolated_pawn_penalty + doubled_pawn_penalty + passed_pawn_bonus
        self.pawn_structure_table[pawn_hash] = (pawn_structure_score, passed_pawns)
        return pawn_structure_score, passed_pawns

    def evaluate_king_safety(self, color, piece_map, total_material):
        king_square = self.board.king(color)
        if king_square is None:
            return 0

        safety_score = 0
        king_rank = chess.square_rank(king_square)
        king_file = chess.square_file(king_square)

        # Phạt nếu vua ở trung tâm trong trung cuộc
        if total_material > 1500 and 2 <= king_file <= 5 and 2 <= king_rank <= 5:
            safety_score -= 30  # Tăng mức phạt để khuyến khích nhập thành

        # Thưởng nếu có lá chắn tốt trước vua
        pawn_shield_bonus = 0
        pawn_shield_squares = []
        if color == chess.WHITE:
            if 0 <= king_file <= 2:  # Nhập thành cánh vua
                pawn_shield_squares = [chess.square(king_file + i, king_rank + 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]
            elif 5 <= king_file <= 7:  # Nhập thành cánh hậu
                pawn_shield_squares = [chess.square(king_file + i, king_rank + 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]
        else:
            if 0 <= king_file <= 2:
                pawn_shield_squares = [chess.square(king_file + i, king_rank - 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]
            elif 5 <= king_file <= 7:
                pawn_shield_squares = [chess.square(king_file + i, king_rank - 1) for i in range(-1, 2) if 0 <= king_file + i <= 7]

        for square in pawn_shield_squares:
            piece = piece_map.get(square)
            if piece and piece.piece_type == chess.PAWN and piece.color == color:
                pawn_shield_bonus += 10  # Tăng thưởng để khuyến khích nhập thành

        # Phạt nếu vua bị tấn công
        attack_units = 0
        attackers = self.board.attackers(not color, king_square)
        for attacker_square in attackers:
            attacker = piece_map.get(attacker_square)
            if attacker:
                if attacker.piece_type == chess.PAWN:
                    attack_units += 1
                elif attacker.piece_type in [chess.KNIGHT, chess.BISHOP]:
                    attack_units += 2
                elif attacker.piece_type == chess.ROOK:
                    attack_units += 3
                elif attacker.piece_type == chess.QUEEN:
                    attack_units += 5

        safety_score -= attack_units * 3
        safety_score += pawn_shield_bonus
        if self.board.has_castling_rights(color):
            safety_score += 30  # Tăng thưởng để khuyến khích nhập thành
        # Thưởng nếu đã nhập thành
        if (color == chess.WHITE and (king_square in [chess.G1, chess.C1])) or \
           (color == chess.BLACK and (king_square in [chess.G8, chess.C8])):
            safety_score += 50  # Thưởng lớn nếu đã nhập thành

        return safety_score

    def evaluate_board(self):
        # Kiểm tra trạng thái kết thúc ván trước tiên
        if self.board.is_checkmate():
            return -float('inf') if self.board.turn == chess.WHITE else float('inf')
        if self.board.is_stalemate() or self.board.is_insufficient_material():
            return 0

        # Kiểm tra trạng thái chiếu
        if self.board.is_check():
            # Thưởng/phạt nhẹ nếu đang chiếu/đang bị chiếu
            check_bonus = 50 if self.board.turn == chess.BLACK else -50
        else:
            check_bonus = 0

        if self.use_nnue:
            return self.nnue.evaluate(self.board)

        # Tính giá trị quân cờ và tổng vật chất
        material_score = 0
        total_material = 0
        for square in chess.SQUARES:
            piece = self.board.piece_at(square)
            if piece:
                value = self.piece_values[piece.piece_type]
                if piece.piece_type != chess.KING:
                    total_material += value
                if piece.color == chess.WHITE:
                    material_score += value
                else:
                    material_score -= value

        # Xác định giai đoạn ván cờ
        game_phase = min(1.0, max(0.0, (total_material - 1500) / (4000 - 1500)))

        # Lấy bản đồ quân cờ
        piece_map = self.board.piece_map()

        # Khởi tạo các điểm số
        position_score = 0
        center_control_score = 0
        king_safety_score = 0
        pawn_structure_score, passed_pawns = self.evaluate_pawn_structure()
        development_score = 0
        mobility_score = 0
        bishop_pair_bonus = 0
        rook_open_file_bonus = 0

        white_bishops = 0
        black_bishops = 0
        white_developed_pieces = 0
        black_developed_pieces = 0

        # Đánh giá vị trí quân và các yếu tố khác
        for square in chess.SQUARES:
            piece = piece_map.get(square)
            if not piece:
                continue

            # Đếm số lượng quân để tính điểm đôi tượng
            if piece.piece_type == chess.BISHOP:
                if piece.color == chess.WHITE:
                    white_bishops += 1
                else:
                    black_bishops += 1

            # Tính điểm vị trí
            table_idx = square if piece.color == chess.WHITE else 63 - square
            if piece.piece_type == chess.PAWN:
                position_score += self.pawn_table[table_idx] * (1 if piece.color == chess.WHITE else -1)
            elif piece.piece_type == chess.KNIGHT:
                position_score += self.knight_table[table_idx] * (1 if piece.color == chess.WHITE else -1)
            elif piece.piece_type == chess.BISHOP:
                position_score += self.bishop_table[table_idx] * (1 if piece.color == chess.WHITE else -1)
            elif piece.piece_type == chess.ROOK:
                position_score += self.rook_table[table_idx] * (1 if piece.color == chess.WHITE else -1)
            elif piece.piece_type == chess.QUEEN:
                position_score += self.queen_table[table_idx] * (1 if piece.color == chess.WHITE else -1)
            elif piece.piece_type == chess.KING:
                if total_material > 1500:  # Trung cuộc
                    position_score += self.king_table_middle[table_idx] * (1 if piece.color == chess.WHITE else -1)
                else:  # Tàn cuộc
                    position_score += self.king_table_endgame[table_idx] * (1 if piece.color == chess.WHITE else -1)

            # Đánh giá phát triển quân (trong 10 nước đầu)
            if len(self.board.move_stack) < 10 and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                rank = chess.square_rank(square)
                if piece.color == chess.WHITE and rank > 1:
                    white_developed_pieces += 1
                elif piece.color == chess.BLACK and rank < 6:
                    black_developed_pieces += 1

            # Đánh giá xe ở cột mở
            if piece.piece_type == chess.ROOK:
                file = chess.square_file(square)
                is_open = True
                for r in range(8):
                    s = chess.square(file, r)
                    if s != square:
                        other_piece = piece_map.get(s)
                        if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == piece.color:
                            is_open = False
                            break
                if is_open:
                    rook_open_file_bonus += 15 if piece.color == chess.WHITE else -15

        # Thưởng đôi tượng
        if white_bishops >= 2:
            bishop_pair_bonus += 25
        if black_bishops >= 2:
            bishop_pair_bonus -= 25

        # Đánh giá kiểm soát trung tâm
        center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]
        for square in center_squares:
            piece = piece_map.get(square)
            if piece:
                if piece.piece_type == chess.PAWN:
                    center_control_score += 15 if piece.color == chess.WHITE else -15
                else:
                    center_control_score += 8 if piece.color == chess.WHITE else -8

        # Đánh giá phát triển quân trong mở cuộc
        if len(self.board.move_stack) < 10:
            development_score += white_developed_pieces * 12  # Tăng từ 8 lên 12 để khuyến khích phát triển quân
            development_score -= black_developed_pieces * 12

        # Đánh giá tính di động
        original_turn = self.board.turn
        self.board.turn = chess.WHITE
        white_mobility = len(list(self.board.legal_moves))
        self.board.turn = chess.BLACK
        black_mobility = len(list(self.board.legal_moves))
        self.board.turn = original_turn
        mobility_score += (white_mobility - black_mobility) * 3

        # Đánh giá an toàn vua
        white_king_safety = self.evaluate_king_safety(chess.WHITE, piece_map, total_material)
        black_king_safety = self.evaluate_king_safety(chess.BLACK, piece_map, total_material)
        king_safety_score = white_king_safety - black_king_safety

        # Tổng hợp điểm số
        eval_score = (material_score +
                      position_score +
                      center_control_score +
                      king_safety_score +
                      pawn_structure_score +
                      development_score +
                      mobility_score +
                      bishop_pair_bonus +
                      rook_open_file_bonus +
                      check_bonus)

        return eval_score