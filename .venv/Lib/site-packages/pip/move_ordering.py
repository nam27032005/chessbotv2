import chess

class MoveOrdering:
    def __init__(self, board, piece_values):
        self.board = board
        self.piece_values = piece_values

    def static_exchange_evaluation(self, move):
        if not self.board.is_capture(move):
            return 0

        to_square = move.to_square
        from_square = move.from_square
        moving_piece = self.board.piece_at(from_square)
        captured_piece = self.board.piece_at(to_square)

        if not moving_piece or not captured_piece:
            return 0

        see_value = self.piece_values[captured_piece.piece_type]
        balance = see_value
        occupied = self.board.occupied
        color = not moving_piece.color

        attackers = []
        for c in [chess.WHITE, chess.BLACK]:
            for square in self.board.attackers(c, to_square):
                piece = self.board.piece_at(square)
                if piece:
                    attackers.append((square, piece.piece_type, piece.color))

        attackers.sort(key=lambda x: self.piece_values[x[1]])

        i = 0
        while i < len(attackers):
            square, piece_type, piece_color = attackers[i]
            if piece_color != color:
                i += 1
                continue

            balance -= self.piece_values[piece_type]
            if balance < 0:
                break

            occupied ^= chess.BB_SQUARES[square]
            color = not color
            i += 1

            new_attacks = []
            for c in [chess.WHITE, chess.BLACK]:
                new_attackers = self.board.attackers_mask(c, to_square, occupied)
                for sq in chess.SquareSet(new_attackers):
                    piece = self.board.piece_at(sq)
                    if piece and (sq, piece.piece_type, piece.color) not in attackers[:i]:
                        new_attacks.append((sq, piece.piece_type, piece.color))
            new_attacks.sort(key=lambda x: self.piece_values[x[1]])
            attackers.extend(new_attacks)

        return balance

    def _compute_move_info(self, moves):
        move_checks = {}
        threatened_pieces = {}
        see_scores = {}
        opponent_captures = []

        original_turn = self.board.turn
        self.board.turn = not self.board.turn
        for move in self.board.legal_moves:
            if self.board.is_capture(move):
                captured_piece = self.board.piece_at(move.to_square)
                if captured_piece:
                    see_score = self.static_exchange_evaluation(move)
                    if see_score >= 0:
                        opponent_captures.append((move, see_score))
        self.board.turn = original_turn

        for move in moves:
            see_scores[move] = self.static_exchange_evaluation(move)
            self.board.push(move)
            move_checks[move] = self.board.is_check()
            self.board.pop()

            moving_piece = self.board.piece_at(move.from_square)
            if moving_piece:
                attackers = self.board.attackers(not moving_piece.color, move.from_square)
                if attackers:
                    min_attacker_value = min(self.piece_values[self.board.piece_at(sq).piece_type] for sq in attackers)
                    threatened_pieces[move] = (moving_piece.piece_type, min_attacker_value)

        return move_checks, threatened_pieces, see_scores, opponent_captures

    def _score_tt_move(self, move, tt_move):
        return 1000000 if move == tt_move else 0

    def _score_capture(self, move, see_score):
        if not self.board.is_capture(move):
            return 0

        if self.board.is_en_passant(move):
            return 500000 + see_score * 10

        captured_piece = self.board.piece_at(move.to_square)
        moving_piece = self.board.piece_at(move.from_square)
        if not captured_piece or not moving_piece:
            return 0

        capture_score = self.piece_values[captured_piece.piece_type] * 100 - self.piece_values[moving_piece.piece_type]
        base_score = 600000 if self.piece_values[captured_piece.piece_type] >= self.piece_values[moving_piece.piece_type] else 400000
        return base_score + capture_score + see_score * 10

    def _score_promotion(self, move):
        return (300000 + self.piece_values[move.promotion] * 100) if move.promotion else 0

    def _score_check(self, move, move_checks):
        return 200000 if move_checks.get(move, False) else 0

    def _score_killer(self, move, depth, killer_moves):
        return 100000 if depth in killer_moves and move in killer_moves[depth] else 0

    def _score_counter(self, move, last_move, counter_move_table):
        if last_move:
            counter_move = counter_move_table.get(last_move.from_square, {}).get(last_move.to_square)
            return 90000 if counter_move == move else 0
        return 0

    def _score_history(self, move, history_table):
        move_key = (move.from_square, move.to_square)
        return history_table.get(move_key, 0) * 10

    def _score_opening(self, move):
        if len(self.board.move_stack) >= 10:
            return 0

        score = 0
        moving_piece = self.board.piece_at(move.from_square)
        if moving_piece:
            if moving_piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                score += 500
                # Phạt nếu quân bị đuổi ngay sau khi di chuyển (như Ng4 bị h3)
                self.board.push(move)
                original_turn = self.board.turn
                self.board.turn = not self.board.turn
                for opp_move in self.board.legal_moves:
                    if opp_move.from_square in [chess.G2, chess.G7] and opp_move.to_square in [chess.G3, chess.H3, chess.G6, chess.H6]:
                        if self.board.piece_at(opp_move.to_square) == moving_piece:
                            score -= 300  # Tăng phạt
                            break
                self.board.turn = original_turn
                self.board.pop()
            elif moving_piece.piece_type == chess.QUEEN:
                if len(self.board.move_stack) < 6:
                    knights_developed = 0
                    bishops_developed = 0
                    for square in chess.SQUARES:
                        piece = self.board.piece_at(square)
                        if piece and piece.color == self.board.turn:
                            rank = chess.square_rank(square)
                            if piece.piece_type == chess.KNIGHT:
                                if (self.board.turn == chess.WHITE and rank > 1) or (self.board.turn == chess.BLACK and rank < 6):
                                    knights_developed += 1
                            if piece.piece_type == chess.BISHOP:
                                if (self.board.turn == chess.WHITE and rank > 1) or (self.board.turn == chess.BLACK and rank < 6):
                                    bishops_developed += 1
                    if knights_developed + bishops_developed < 2:
                        score -= 600
                    else:
                        score -= 200
                else:
                    score -= 200
            elif moving_piece.piece_type in [chess.KING, chess.ROOK]:
                if moving_piece.piece_type == chess.KING and \
                   move not in [chess.Move.from_uci(m) for m in ["e1g1", "e1c1", "e8g8", "e8c8"]]:
                    score -= 500
                elif moving_piece.piece_type == chess.ROOK:
                    knights_developed = 0
                    bishops_developed = 0
                    for square in chess.SQUARES:
                        piece = self.board.piece_at(square)
                        if piece and piece.color == self.board.turn:
                            rank = chess.square_rank(square)
                            if piece.piece_type == chess.KNIGHT:
                                if (self.board.turn == chess.WHITE and rank > 1) or (self.board.turn == chess.BLACK and rank < 6):
                                    knights_developed += 1
                            if piece.piece_type == chess.BISHOP:
                                if (self.board.turn == chess.WHITE and rank > 1) or (self.board.turn == chess.BLACK and rank < 6):
                                    bishops_developed += 1
                    if knights_developed + bishops_developed < 2:
                        score -= 600
                    else:
                        score -= 200
                else:
                    score -= 200

        if move in [chess.Move.from_uci(m) for m in ["e1g1", "e1c1", "e8g8", "e8c8"]]:
            knights_developed = 0
            bishops_developed = 0
            for square in chess.SQUARES:
                piece = self.board.piece_at(square)
                if piece and piece.color == self.board.turn:
                    rank = chess.square_rank(square)
                    if piece.piece_type == chess.KNIGHT:
                        if (self.board.turn == chess.WHITE and rank > 1) or (self.board.turn == chess.BLACK and rank < 6):
                            knights_developed += 1
                    if piece.piece_type == chess.BISHOP:
                        if (self.board.turn == chess.WHITE and rank > 1) or (self.board.turn == chess.BLACK and rank < 6):
                            bishops_developed += 1
            if knights_developed + bishops_developed >= 2:
                score += 500
            else:
                score += 400
        elif move.to_square in [chess.D4, chess.D5, chess.E4, chess.E5]:
            score += 450
        elif moving_piece and moving_piece.piece_type == chess.KNIGHT and \
             move.from_square in [chess.G1, chess.G8, chess.F3, chess.F6]:
            score += 500

        if self.board.is_capture(move) and not self.board.is_en_passant(move):
            captured_piece = self.board.piece_at(move.to_square)
            if captured_piece and captured_piece.piece_type == chess.KNIGHT:
                score += 250

        if moving_piece and moving_piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
            rank = chess.square_rank(move.to_square)
            if (self.board.turn == chess.WHITE and rank <= 1) or (self.board.turn == chess.BLACK and rank >= 6):
                score -= 500  # Tăng phạt
            if (self.board.turn == chess.WHITE and move.from_square in [chess.F3, chess.C3] and rank <= 1) or \
               (self.board.turn == chess.BLACK and move.from_square in [chess.F6, chess.C6] and rank >= 6):
                score -= 150

        return score

    def _score_threatened(self, move, threatened_pieces):
        if move not in threatened_pieces:
            return 0

        piece_type, min_attacker_value = threatened_pieces[move]
        if min_attacker_value <= self.piece_values[piece_type]:
            self.board.push(move)
            new_attackers = self.board.attackers(not self.board.piece_at(move.to_square).color, move.to_square)
            self.board.pop()
            return 100000 if not new_attackers else 70000
        return 0

    def _score_opponent_capture(self, move, opponent_captures):
        score = 0
        for opp_move, see_score in opponent_captures:
            if opp_move.to_square == move.from_square:
                captured_piece = self.board.piece_at(move.from_square)
                attacker_piece = self.board.piece_at(opp_move.from_square)
                if captured_piece and attacker_piece:
                    if self.piece_values[attacker_piece.piece_type] < self.piece_values[captured_piece.piece_type]:
                        self.board.push(move)
                        original_turn = self.board.turn
                        self.board.turn = not self.board.turn
                        for next_move in self.board.legal_moves:
                            next_captured_piece = self.board.piece_at(next_move.to_square)
                            if next_captured_piece and next_captured_piece.piece_type == chess.QUEEN:
                                score -= 2000
                                self.board.turn = original_turn
                                self.board.pop()
                                return score
                        self.board.turn = original_turn
                        self.board.pop()
                        score -= (self.piece_values[captured_piece.piece_type] - self.piece_values[attacker_piece.piece_type]) * 3.0
        return score

    def _score_attack_risk(self, move, move_checks):
        if self.board.is_capture(move) or move_checks.get(move, False):
            return 0

        to_square = move.to_square
        defenders = self.board.attackers(self.board.turn, to_square)
        attackers = self.board.attackers(not self.board.turn, to_square)
        # Phạt nếu quân di chuyển đến vị trí bị đe dọa nhiều hơn bảo vệ
        if len(attackers) >= len(defenders) and len(defenders) <= 1:
            return -30000
        # Phạt nếu quân bị ghim sau khi di chuyển
        self.board.push(move)
        original_turn = self.board.turn
        self.board.turn = not self.board.turn
        for opp_move in self.board.legal_moves:
            if self.board.is_capture(opp_move):
                captured_piece = self.board.piece_at(opp_move.to_square)
                if captured_piece and captured_piece.piece_type == chess.QUEEN:
                    self.board.turn = original_turn
                    self.board.pop()
                    return -50000  # Phạt nặng nếu bị ghim dẫn đến mất hậu
        self.board.turn = original_turn
        self.board.pop()
        return 0

    def _score_king_exposure(self, move):
        score = 0
        moving_piece = self.board.piece_at(move.from_square)
        if moving_piece and moving_piece.piece_type == chess.PAWN:
            file = chess.square_file(move.from_square)
            if file in [5, 6, 7]:
                self.board.push(move)
                original_turn = self.board.turn
                self.board.turn = not self.board.turn
                for opp_move in self.board.legal_moves:
                    if self.board.gives_check(opp_move):
                        score -= 200
                        break
                self.board.turn = original_turn
                self.board.pop()
        return score

    def _score_center_loss(self, move):
        score = 0
        center_squares = [chess.D5, chess.E5] if self.board.turn == chess.WHITE else [chess.D4, chess.E4]
        for square in center_squares:
            piece = self.board.piece_at(square)
            if piece and piece.piece_type == chess.PAWN and piece.color == self.board.turn:
                defenders = self.board.attackers(self.board.turn, square)
                attackers = self.board.attackers(not self.board.turn, square)
                if len(attackers) > len(defenders):
                    self.board.push(move)
                    new_defenders = self.board.attackers(self.board.turn, square)
                    new_attackers = self.board.attackers(not self.board.turn, square)
                    self.board.pop()
                    if len(new_attackers) > len(new_defenders) and len(new_defenders) == 0:
                        score -= 100
        return score

    def sort_moves(self, moves, depth, killer_moves, history_table, counter_move_table, last_move, transposition_table,
                   zobrist_hasher=None):
        zobrist_hash = zobrist_hasher.hash_board(self.board) if zobrist_hasher else 0
        tt_move = None
        tt_entry = transposition_table.get(zobrist_hash, depth)
        if tt_entry and tt_entry[1] >= depth:
            tt_move = tt_entry[3]

        move_checks, threatened_pieces, see_scores, opponent_captures = self._compute_move_info(moves)

        def move_score(move):
            score = 0
            score += self._score_tt_move(move, tt_move)
            score += self._score_capture(move, see_scores.get(move, 0))
            score += self._score_promotion(move)
            score += self._score_check(move, move_checks)
            score += self._score_killer(move, depth, killer_moves)
            score += self._score_counter(move, last_move, counter_move_table)
            score += self._score_history(move, history_table)
            score += self._score_opening(move)
            score += self._score_threatened(move, threatened_pieces)
            score += self._score_opponent_capture(move, opponent_captures)
            score += self._score_attack_risk(move, move_checks)
            score += self._score_king_exposure(move)
            score += self._score_center_loss(move)
            return score

        return sorted(moves, key=move_score, reverse=True)