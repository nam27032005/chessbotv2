import chess

class MoveOrdering:
    def __init__(self, board, piece_values):
        self.board = board
        self.piece_values = piece_values

    def static_exchange_evaluation(self, move):
        if not self.board.is_capture(move):
            return 0

        see_values = []
        to_square = move.to_square
        from_square = move.from_square
        moving_piece = self.board.piece_at(from_square)
        captured_piece = self.board.piece_at(to_square)

        if not moving_piece or not captured_piece:
            return 0

        see_values.append(self.piece_values[captured_piece.piece_type])
        self.board.push(move)

        attacks = []
        for square in chess.SQUARES:
            piece = self.board.piece_at(square)
            if piece and self.board.is_attacker(square, to_square):
                attacks.append((square, piece.piece_type, piece.color))

        attacks.sort(key=lambda x: self.piece_values[x[1]])

        color = not moving_piece.color
        balance = 0
        i = 0

        while i < len(attacks):
            square, piece_type, piece_color = attacks[i]
            if piece_color != color:
                i += 1
                continue

            see_values.append(self.piece_values[piece_type])
            balance = see_values[0] - sum(see_values[1:])

            if balance < 0:
                break

            color = not color
            i += 1

            new_attacks = []
            for sq in chess.SQUARES:
                piece = self.board.piece_at(sq)
                if piece and self.board.is_attacker(sq, to_square) and (sq, piece.piece_type, piece.color) not in attacks[:i]:
                    new_attacks.append((sq, piece.piece_type, piece.color))
            new_attacks.sort(key=lambda x: self.piece_values[x[1]])
            attacks.extend(new_attacks)

        self.board.pop()
        return see_values[0] - sum(see_values[1:])

    def sort_moves(self, moves, depth, killer_moves, history_table, counter_move_table, last_move, transposition_table, zobrist_hasher=None):
        zobrist_hash = zobrist_hasher.hash_board(self.board) if zobrist_hasher else 0
        tt_move = None
        # Sử dụng phương thức get thay vì kiểm tra "in"
        tt_entry = transposition_table.get(zobrist_hash, depth)
        if tt_entry:
            tt_score, tt_depth, tt_flag, tt_move = tt_entry
            if tt_depth >= depth:
                tt_move = tt_entry[3]

        def move_score(move):
            score = 0
            if move == tt_move:
                score += 100000

            if self.board.is_capture(move):
                if self.board.is_en_passant(move):
                    score += 5000
                else:
                    captured_piece = self.board.piece_at(move.to_square)
                    moving_piece = self.board.piece_at(move.from_square)
                    if captured_piece and moving_piece:
                        score += (self.piece_values[captured_piece.piece_type] * 100 -
                                 self.piece_values[moving_piece.piece_type])

            self.board.push(move)
            if self.board.is_check():
                score += 10000
            self.board.pop()

            if depth in killer_moves and move in killer_moves[depth]:
                score += 9000

            move_key = (move.from_square, move.to_square)
            if move_key in history_table:
                score += history_table[move_key] * depth

            if last_move is not None:
                last_from, last_to = last_move.from_square, last_move.to_square
                counter_move = counter_move_table.get(last_from, {}).get(last_to)
                if counter_move == move:
                    score += 8000

            return score

        return sorted(moves, key=move_score, reverse=True)