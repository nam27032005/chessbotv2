import chess
class MoveOrdering:
    def __init__(self, board, piece_values):
        self.board = board
        self.piece_values = piece_values

    def static_exchange_evaluation(self, move):
        if not self.board.is_capture(move):
            return 0

        see_values = []
        to_square = move.to_square
        from_square = move.from_square
        moving_piece = self.board.piece_at(from_square)
        captured_piece = self.board.piece_at(to_square)

        if not moving_piece or not captured_piece:
            return 0

        see_values.append(self.piece_values[captured_piece.piece_type])
        self.board.push(move)

        attacks = []
        for color in [chess.WHITE, chess.BLACK]:
            attackers = self.board.attackers(color, to_square)
            for square in attackers:
                piece = self.board.piece_at(square)
                if piece:
                    attacks.append((square, piece.piece_type, piece.color))

        attacks.sort(key=lambda x: self.piece_values[x[1]])

        color = not moving_piece.color
        balance = 0
        i = 0

        while i < len(attacks):
            square, piece_type, piece_color = attacks[i]
            if piece_color != color:
                i += 1
                continue

            see_values.append(self.piece_values[piece_type])
            balance = see_values[0] - sum(see_values[1:])

            if balance < 0:
                break

            color = not color
            i += 1

            new_attacks = []
            for c in [chess.WHITE, chess.BLACK]:
                new_attackers = self.board.attackers(c, to_square)
                for sq in new_attackers:
                    piece = self.board.piece_at(sq)
                    if piece and (sq, piece.piece_type, piece.color) not in attacks[:i]:
                        new_attacks.append((sq, piece.piece_type, piece.color))
            new_attacks.sort(key=lambda x: self.piece_values[x[1]])
            attacks.extend(new_attacks)

        self.board.pop()
        return see_values[0] - sum(see_values[1:])

    def sort_moves(self, moves, depth, killer_moves, history_table, counter_move_table, last_move, transposition_table,
                   zobrist_hasher=None):
        zobrist_hash = zobrist_hasher.hash_board(self.board) if zobrist_hasher else 0
        tt_move = None
        tt_entry = transposition_table.get(zobrist_hash, depth)
        if tt_entry:
            tt_score, tt_depth, tt_flag, tt_move = tt_entry
            if tt_depth >= depth:
                tt_move = tt_entry[3]

        def move_score(move):
            score = 0

            # 1. Ưu tiên nước đi từ transposition table
            if move == tt_move:
                score += 1000000

            # 2. Ưu tiên nước đi bắt quân với SEE tốt
            if self.board.is_capture(move):
                see_score = self.static_exchange_evaluation(move)
                if self.board.is_en_passant(move):
                    score += 500000 + see_score
                else:
                    captured_piece = self.board.piece_at(move.to_square)
                    moving_piece = self.board.piece_at(move.from_square)
                    if captured_piece and moving_piece:
                        capture_score = self.piece_values[captured_piece.piece_type] * 100 - self.piece_values[
                            moving_piece.piece_type]
                        # Ưu tiên đổi quân nếu giá trị bằng nhau
                        if self.piece_values[captured_piece.piece_type] >= self.piece_values[moving_piece.piece_type]:
                            score += 600000 + capture_score + see_score * 10  # Ưu tiên đổi quân giá trị bằng nhau hoặc cao hơn
                        else:
                            score += 400000 + capture_score + see_score * 10  # Bắt quân giá trị thấp hơn

            # 3. Ưu tiên nước đi thăng cấp
            if move.promotion:
                score += 300000 + self.piece_values[move.promotion] * 100

            # 4. Ưu tiên nước đi chiếu
            self.board.push(move)
            if self.board.is_check():
                score += 200000
            self.board.pop()

            # 5. Ưu tiên killer moves
            if depth in killer_moves and move in killer_moves[depth]:
                score += 100000

            # 6. Ưu tiên counter moves
            if last_move is not None:
                last_from, last_to = last_move.from_square, last_move.to_square
                counter_move = counter_move_table.get(last_from, {}).get(last_to)
                if counter_move == move:
                    score += 90000

            # 7. Ưu tiên dựa trên history table
            move_key = (move.from_square, move.to_square)
            if move_key in history_table:
                score += history_table[move_key]

            # 8. Trong 10 nước đầu, ưu tiên phát triển quân nhẹ và nhập thành, hạn chế đi hậu
            if len(self.board.move_stack) < 10:
                moving_piece = self.board.piece_at(move.from_square)
                if moving_piece:
                    # Ưu tiên phát triển mã và tượng
                    if moving_piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                        score += 150000  # Thưởng cho nước đi phát triển mã và tượng
                    # Hạn chế đi hậu
                    elif moving_piece.piece_type == chess.QUEEN:
                        score -= 100000  # Phạt nước đi của hậu trong khai cuộc

                # Ưu tiên nước đi nhập thành hoặc chuẩn bị nhập thành
                move_san = self.board.san(move)
                if move_san in ["O-O", "O-O-O"]:  # Nhập thành
                    score += 200000
                elif move_san in ["Nf3", "Nf6", "d4", "d5", "e4", "e5"]:  # Chuẩn bị nhập thành
                    score += 120000

            # 9. Bảo vệ quân bị đe dọa
            moving_piece = self.board.piece_at(move.from_square)
            if moving_piece:
                attackers = self.board.attackers(not moving_piece.color, move.from_square)
                if attackers:  # Quân đang bị đe dọa
                    # Tính giá trị của quân tấn công
                    min_attacker_value = float('inf')
                    for attacker_square in attackers:
                        attacker = self.board.piece_at(attacker_square)
                        if attacker:
                            min_attacker_value = min(min_attacker_value, self.piece_values[attacker.piece_type])

                    # Nếu giá trị quân tấn công nhỏ hơn hoặc bằng giá trị quân bị đe dọa, ưu tiên bảo vệ
                    if min_attacker_value <= self.piece_values[moving_piece.piece_type]:
                        # Kiểm tra xem nước đi này có đưa quân ra vị trí an toàn không
                        self.board.push(move)
                        new_attackers = self.board.attackers(not moving_piece.color, move.to_square)
                        self.board.pop()
                        if not new_attackers:  # Quân đã an toàn sau khi di chuyển
                            score += 70000  # Ưu tiên di chuyển quân ra vị trí an toàn
                        else:
                            score += 50000  # Vẫn bị đe dọa nhưng đã di chuyển, ưu tiên thấp hơn

            return score

        return sorted(moves, key=move_score, reverse=True)