import chess
import time
import math
from evaluation import evaluate_board, get_game_phase

class ChessBot:
    def __init__(self, ai_turn):
        self.ai_turn = ai_turn
        self.best_move = None
        self.total_nodes = 0
        self.total_branch_cutoff = 0
        self.total_nodes_leaf = 0
        self.execution_time = 0
        self.time_generate_moves = 0
        self.is_endgame = False

    def reset_parameters(self):
        self.best_move = None
        self.total_nodes = 0
        self.total_branch_cutoff = 0
        self.total_nodes_leaf = 0
        self.time_generate_moves = 0

    def is_pawn_threatened(self, board, pawn_square):
        """Kiểm tra xem một quân tốt có bị đe dọa hay không."""
        opponent_color = chess.WHITE if self.ai_turn == chess.BLACK else chess.BLACK
        attackers = board.attackers(opponent_color, pawn_square)
        if attackers:
            defenders = board.attackers(self.ai_turn, pawn_square)
            return len(attackers) > len(defenders)
        return False

    def is_column_open(self, board, file):
        """Kiểm tra xem một cột có mở không (không còn tốt của bên mình)."""
        for rank in range(8):
            square = chess.square(file, rank)
            piece = board.piece_at(square)
            if piece and piece.piece_type == chess.PAWN and piece.color == self.ai_turn:
                return False
        return True

    def prioritize_opening_moves(self, board, moves):
        if len(board.move_stack) >= 10:  # Sau 10 nước, không ưu tiên khai cuộc
            prioritized_moves = []
            remaining_moves = []

            for move in moves:
                move_str = move.uci()
                piece = board.piece_at(move.from_square)
                if piece is None:
                    continue

                # Cấm di chuyển vua nếu không phải nhập thành
                if piece.piece_type == chess.KING and move_str not in ["e1g1", "e1c1", "e8g8", "e8c8"]:
                    continue

                # Kiểm tra di chuyển xe
                if piece.piece_type == chess.ROOK:
                    to_square = move.to_square
                    file = chess.square_file(to_square)
                    if self.is_column_open(board, file):
                        prioritized_moves.append(move)
                    else:
                        for rank in range(8):
                            square = chess.square(file, rank)
                            piece_at_square = board.piece_at(square)
                            if piece_at_square and piece_at_square.piece_type == chess.PAWN and piece_at_square.color == self.ai_turn:
                                if self.is_pawn_threatened(board, square):
                                    prioritized_moves.append(move)
                                    break
                        else:
                            continue
                    continue

                # Kiểm tra di chuyển mã
                if piece.piece_type == chess.KNIGHT:
                    to_square = move.to_square
                    if to_square in [chess.A8, chess.H8, chess.A1, chess.H1]:
                        continue
                    if (self.ai_turn == chess.WHITE and to_square in [chess.G1, chess.B1]) or \
                       (self.ai_turn == chess.BLACK and to_square in [chess.G8, chess.B8]):
                        continue
                    if to_square in [chess.D2, chess.E2, chess.D3, chess.E3, chess.F3, chess.C3] and self.ai_turn == chess.WHITE:
                        prioritized_moves.append(move)
                        continue
                    if to_square in [chess.D7, chess.E7, chess.D6, chess.E6, chess.F6, chess.C6] and self.ai_turn == chess.BLACK:
                        prioritized_moves.append(move)
                        continue

                remaining_moves.append(move)

            return prioritized_moves + remaining_moves

        prioritized_moves = []
        remaining_moves = []

        # Ưu tiên nhập thành: Kiểm tra và chọn ngay nếu có thể
        for move in moves:
            move_str = move.uci()
            if move_str in ["e1g1", "e1c1", "e8g8", "e8c8"]:
                if self.ai_turn == chess.WHITE:
                    if move_str == "e1g1" and board.has_kingside_castling_rights(chess.WHITE):
                        return [move]  # Chọn ngay nước nhập thành
                    if move_str == "e1c1" and board.has_queenside_castling_rights(chess.WHITE):
                        return [move]
                elif self.ai_turn == chess.BLACK:
                    if move_str == "e8g8" and board.has_kingside_castling_rights(chess.BLACK):
                        return [move]  # Chọn ngay nước nhập thành
                    if move_str == "e8c8" and board.has_queenside_castling_rights(chess.BLACK):
                        return [move]

        for move in moves:
            move_str = move.uci()
            piece = board.piece_at(move.from_square)
            if piece is None:
                continue

            # Cấm di chuyển vua trong giai đoạn khai cuộc (trừ nhập thành)
            if piece.piece_type == chess.KING and move_str not in ["e1g1", "e1c1", "e8g8", "e8c8"]:
                continue

            # Cấm di chuyển xe trong giai đoạn khai cuộc
            if piece.piece_type == chess.ROOK:
                continue

            # Kiểm tra di chuyển mã
            if piece.piece_type == chess.KNIGHT:
                to_square = move.to_square
                if to_square in [chess.A8, chess.H8, chess.A1, chess.H1]:
                    continue
                if (self.ai_turn == chess.WHITE and to_square in [chess.G1, chess.B1]) or \
                   (self.ai_turn == chess.BLACK and to_square in [chess.G8, chess.B8]):
                    continue
                if to_square in [chess.D2, chess.E2, chess.D3, chess.E3, chess.F3, chess.C3] and self.ai_turn == chess.WHITE:
                    prioritized_moves.append(move)
                    continue
                if to_square in [chess.D7, chess.E7, chess.D6, chess.E6, chess.F6, chess.C6] and self.ai_turn == chess.BLACK:
                    prioritized_moves.append(move)
                    continue

            # Ưu tiên 1: Đẩy tốt E (e4/e5) hoặc D (d4/d5)
            if piece.piece_type == chess.PAWN:
                if move_str in ["e2e4", "e7e5", "d2d4", "d7d5"]:
                    prioritized_moves.append(move)
                    continue

            # Ưu tiên 2: Phát triển tượng (bishop) ra các ô chiến lược
            if piece.piece_type == chess.BISHOP:
                to_square = move.to_square
                if (self.ai_turn == chess.WHITE and to_square in [chess.C4, chess.F4, chess.D3, chess.E3]) or \
                   (self.ai_turn == chess.BLACK and to_square in [chess.C5, chess.F5, chess.D6, chess.E6]):
                    prioritized_moves.append(move)
                    continue

            # Ưu tiên 3: Nhập thành (đã kiểm tra ở trên, nếu không chọn ngay thì thêm vào danh sách ưu tiên)
            if move_str in ["e1g1", "e1c1", "e8g8", "e8c8"]:
                prioritized_moves.append(move)
                continue

            # Các nước đi khác
            remaining_moves.append(move)

        return prioritized_moves + remaining_moves

    def get_best_move(self, board, max_time=3.0):
        self.reset_parameters()
        start_time = time.time()
        self.is_endgame = get_game_phase(board) > 0.8
        depth = 4  # Sử dụng depth = 4 như yêu cầu
        alpha = -float('inf')
        beta = float('inf')

        moves = list(board.legal_moves)
        if not moves:
            return None

        # Ưu tiên nước đi khai cuộc
        prioritized_moves = self.prioritize_opening_moves(board, moves)
        if prioritized_moves and len(prioritized_moves) == 1 and moves[0].uci() in ["e1g1", "e1c1", "e8g8", "e8c8"]:
            # Nếu chỉ có nước nhập thành được ưu tiên, chọn ngay
            self.best_move = prioritized_moves[0]
        else:
            # Thuật toán Alpha-Beta
            max_eval = -float('inf')
            for move in prioritized_moves:
                board.push(move)
                eval_score = self.alphabeta(board, depth - 1, alpha, beta, False)
                board.pop()
                if eval_score > max_eval:
                    max_eval = eval_score
                    self.best_move = move
                alpha = max(alpha, eval_score)

        self.execution_time = time.time() - start_time
        return self.best_move

    def alphabeta(self, board, depth, alpha, beta, maximizing):
        if depth == 0 or board.is_game_over():
            self.total_nodes_leaf += 1
            return evaluate_board(board, self.ai_turn, self.is_endgame)

        start = time.time()
        moves = list(board.legal_moves)
        self.time_generate_moves += time.time() - start

        if maximizing:
            max_eval = -float('inf')
            for move in moves:
                board.push(move)
                self.total_nodes += 1
                eval_score = self.alphabeta(board, depth - 1, alpha, beta, False)
                board.pop()
                if eval_score > max_eval:
                    max_eval = eval_score
                alpha = max(alpha, eval_score)
                if beta <= alpha:
                    self.total_branch_cutoff += 1
                    break
            return max_eval
        else:
            min_eval = float('inf')
            for move in moves:
                board.push(move)
                self.total_nodes += 1
                eval_score = self.alphabeta(board, depth - 1, alpha, beta, True)
                board.pop()
                if eval_score < min_eval:
                    min_eval = eval_score
                beta = min(beta, eval_score)
                if beta <= alpha:
                    self.total_branch_cutoff += 1
                    break
            return min_eval