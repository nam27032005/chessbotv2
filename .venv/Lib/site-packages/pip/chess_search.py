# chess_search.py

import chess
import chess.polyglot
from collections import defaultdict
import multiprocessing as mp
import time
import random


class ChessSearch:
    """Class riêng để xử lý logic tìm kiếm, áp dụng các thuật toán của Stockfish."""
    def __init__(self, board, bot_color, piece_values, pawn_table_opening, pawn_table_middlegame, pawn_table_endgame,
                 knight_table, bishop_table, rook_table, queen_table, king_table_opening, king_table_endgame):
        self.board = board
        self.bot_color = bot_color
        self.piece_values = piece_values
        self.pawn_table_opening = pawn_table_opening
        self.pawn_table_middlegame = pawn_table_middlegame
        self.pawn_table_endgame = pawn_table_endgame
        self.knight_table = knight_table
        self.bishop_table = bishop_table
        self.rook_table = rook_table
        self.queen_table = queen_table
        self.king_table_opening = king_table_opening
        self.king_table_endgame = king_table_endgame
        self.transposition_table = {}
        self.killer_moves = defaultdict(list)
        self.history_table = defaultdict(int)

    def evaluate_board(self):
        if self.board.is_checkmate():
            if self.board.turn == chess.WHITE:
                return -float('inf')
            else:
                return float('inf')
        if self.board.is_stalemate() or self.board.is_insufficient_material():
            return 0

        material_score = 0
        position_score = 0
        center_control_score = 0
        king_safety_score = 0
        pawn_structure_score = 0
        development_score = 0
        mobility_score = 0
        threat_score = 0
        bishop_pair_bonus = 0
        rook_open_file_bonus = 0
        passed_pawn_bonus = 0
        king_activity_score = 0
        outpost_score = 0
        diagonal_control_score = 0
        pinned_piece_penalty = 0
        center_pawn_bonus = 0
        passive_move_penalty = 0
        castling_bonus = 0
        exposed_piece_penalty = 0  # Phạt cho các quân bị lộ (như Bh3)

        total_material = 0
        white_bishops = 0
        black_bishops = 0
        white_developed_pieces = 0
        black_developed_pieces = 0
        white_center_control = 0
        black_center_control = 0

        # Đánh giá vật chất và vị trí
        for square in chess.SQUARES:
            piece = self.board.piece_at(square)
            if piece:
                value = self.piece_values[piece.piece_type]
                if piece.color == chess.WHITE:
                    material_score += value
                    if piece.piece_type == chess.BISHOP:
                        white_bishops += 1
                else:
                    material_score -= value
                    if piece.piece_type == chess.BISHOP:
                        black_bishops += 1

                if piece.piece_type != chess.KING:
                    total_material += value

                rank = chess.square_rank(square)
                file = chess.square_file(square)
                if piece.color == chess.BLACK:
                    rank = 7 - rank

                if piece.piece_type == chess.PAWN:
                    if total_material < 1500:
                        table = self.pawn_table_endgame
                    elif total_material < 3000:
                        table = self.pawn_table_middlegame
                    else:
                        table = self.pawn_table_opening
                elif piece.piece_type == chess.KNIGHT:
                    table = self.knight_table
                elif piece.piece_type == chess.BISHOP:
                    table = self.bishop_table
                elif piece.piece_type == chess.ROOK:
                    table = self.rook_table
                elif piece.piece_type == chess.QUEEN:
                    table = self.queen_table
                elif piece.piece_type == chess.KING:
                    table = self.king_table_endgame if total_material < 1500 else self.king_table_opening
                else:
                    continue

                pos_value = table[rank][file]
                if piece.color == chess.WHITE:
                    position_score += pos_value
                else:
                    position_score -= pos_value

                # Đánh giá mối đe dọa trực tiếp
                attackers = self.board.attackers(not piece.color, square)
                defenders = self.board.attackers(piece.color, square)
                if attackers:
                    min_attacker_value = float('inf')
                    for attacker_square in attackers:
                        attacker = self.board.piece_at(attacker_square)
                        if attacker:
                            attacker_value = self.piece_values[attacker.piece_type]
                            min_attacker_value = min(min_attacker_value, attacker_value)
                    min_defender_value = float('inf')
                    if defenders:
                        for defender_square in defenders:
                            defender = self.board.piece_at(defender_square)
                            if defender:
                                defender_value = self.piece_values[defender.piece_type]
                                min_defender_value = min(min_defender_value, defender_value)
                    else:
                        min_defender_value = float('inf')

                    if min_attacker_value < min_defender_value:
                        threat_value = self.piece_values[piece.piece_type] * 1.0
                        if piece.color == chess.WHITE:
                            threat_score -= threat_value
                        else:
                            threat_score += threat_value

                    # Phạt cho các quân bị lộ (như Bh3)
                    if len(self.board.move_stack) < 10 and piece.piece_type == chess.BISHOP:
                        if piece.color == chess.WHITE and rank >= 5:
                            exposed_piece_penalty -= 0.5  # Phạt nếu Tượng Trắng đi quá xa
                        elif piece.color == chess.BLACK and rank <= 2:
                            exposed_piece_penalty += 0.5  # Phạt nếu Tượng Đen đi quá xa

                if piece.piece_type == chess.PAWN:
                    file = chess.square_file(square)
                    left_file = file - 1 if file > 0 else None
                    right_file = file + 1 if file < 7 else None
                    has_neighbor = False
                    for s in chess.SQUARES:
                        if s != square and chess.square_file(s) in [left_file, right_file]:
                            other_piece = self.board.piece_at(s)
                            if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == piece.color:
                                has_neighbor = True
                                break
                    if not has_neighbor:
                        if piece.color == chess.WHITE:
                            pawn_structure_score -= 0.5
                        else:
                            pawn_structure_score += 0.5

                    for s in chess.SQUARES:
                        if s != square and chess.square_file(s) == file:
                            other_piece = self.board.piece_at(s)
                            if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == piece.color:
                                if piece.color == chess.WHITE:
                                    pawn_structure_score -= 0.3
                                else:
                                    pawn_structure_score += 0.3
                                break

                    is_passed = True
                    for r in range(rank + 1 if piece.color == chess.WHITE else 0,
                                   8 if piece.color == chess.WHITE else rank):
                        s = chess.square(file, r)
                        other_piece = self.board.piece_at(s)
                        if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color != piece.color:
                            is_passed = False
                            break
                    if is_passed:
                        bonus = (rank if piece.color == chess.WHITE else 7 - rank) * 0.5
                        if piece.color == chess.WHITE:
                            passed_pawn_bonus += bonus
                        else:
                            passed_pawn_bonus -= bonus

                    if square in [chess.D4, chess.D5, chess.E4, chess.E5]:
                        if piece.color == chess.WHITE:
                            center_pawn_bonus += 2.0 if total_material > 3000 else 1.0
                        else:
                            center_pawn_bonus -= 2.0 if total_material > 3000 else 1.0

                if piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]:
                    self.board.push(chess.Move.null())
                    self.board.turn = piece.color
                    legal_moves = len(list(self.board.legal_moves))
                    self.board.pop()
                    mobility = legal_moves * (0.05 if total_material > 3000 else 0.15)
                    if piece.color == chess.WHITE:
                        mobility_score += mobility
                    else:
                        mobility_score -= mobility

                if piece.piece_type == chess.ROOK:
                    file = chess.square_file(square)
                    is_open = True
                    for r in range(8):
                        s = chess.square(file, r)
                        if s != square:
                            other_piece = self.board.piece_at(s)
                            if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == piece.color:
                                is_open = False
                                break
                    if is_open:
                        if piece.color == chess.WHITE:
                            rook_open_file_bonus += 0.5
                        else:
                            rook_open_file_bonus -= 0.5

                if piece.piece_type in [chess.BISHOP, chess.QUEEN]:
                    if abs(file - rank) == 0 or abs(file + rank - 7) == 0:
                        diagonal_bonus = 0.1 if total_material > 3000 else 0.3
                        if piece.color == chess.WHITE:
                            diagonal_control_score += diagonal_bonus
                        else:
                            diagonal_control_score -= diagonal_bonus

                if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                    rank = chess.square_rank(square)
                    if piece.color == chess.WHITE and rank >= 4:
                        protected = False
                        for s in chess.SQUARES:
                            if chess.square_file(s) in [file - 1, file + 1] and chess.square_rank(s) < rank:
                                other_piece = self.board.piece_at(s)
                                if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == chess.WHITE:
                                    protected = True
                                    break
                        if protected:
                            outpost_bonus = 0.3 if total_material > 3000 else 0.5
                            outpost_score += outpost_bonus
                    elif piece.color == chess.BLACK and rank <= 3:
                        protected = False
                        for s in chess.SQUARES:
                            if chess.square_file(s) in [file - 1, file + 1] and chess.square_rank(s) > rank:
                                other_piece = self.board.piece_at(s)
                                if other_piece and other_piece.piece_type == chess.PAWN and other_piece.color == chess.BLACK:
                                    protected = True
                                    break
                        if protected:
                            outpost_bonus = 0.3 if total_material > 3000 else 0.5
                            outpost_score -= outpost_bonus

                    if len(self.board.move_stack) < 10:
                        if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                            if piece.color == chess.WHITE and rank > 1:
                                white_developed_pieces += 1
                            elif piece.color == chess.BLACK and rank < 6:
                                black_developed_pieces += 1

                king_square = self.board.king(piece.color)
                if king_square is not None:
                    pin = self.board.pin(not piece.color, square)
                    if pin & (1 << king_square):
                        penalty = self.piece_values[piece.piece_type] * 0.2
                        if piece.color == chess.WHITE:
                            pinned_piece_penalty -= penalty
                        else:
                            pinned_piece_penalty += penalty

                if square in [chess.D4, chess.D5, chess.E4, chess.E5]:
                    if piece.color == chess.WHITE:
                        white_center_control += 1
                    else:
                        black_center_control += 1

        if white_bishops >= 2:
            bishop_pair_bonus += 0.5
        if black_bishops >= 2:
            bishop_pair_bonus -= 0.5

        center_squares = [chess.D4, chess.D5, chess.E4, chess.E5]
        for square in center_squares:
            piece = self.board.piece_at(square)
            if piece:
                if piece.piece_type == chess.PAWN:
                    value = 2.0 if total_material > 3000 else 1.0
                else:
                    value = 0.5
                if piece.color == chess.WHITE:
                    center_control_score += value
                else:
                    center_control_score -= value

        white_king = self.board.king(chess.WHITE)
        black_king = self.board.king(chess.BLACK)
        if white_king:
            white_king_attacks = len(self.board.attackers(chess.BLACK, white_king))
            king_safety_weight = 0.5 if total_material > 3000 else 1.0 if total_material > 1500 else 0.3
            king_safety_score -= white_king_attacks * king_safety_weight
            if self.board.has_castling_rights(chess.WHITE):
                king_safety_score += 1.0
                castling_bonus += 1.5
            if total_material > 3000:
                file = chess.square_file(white_king)
                if 2 <= file <= 5:
                    king_safety_score -= 1.0
            if total_material < 1500:
                rank = chess.square_rank(white_king)
                file = chess.square_file(white_king)
                king_activity_score += (4 - abs(4 - rank) - abs(4 - file)) * 0.2
        if black_king:
            black_king_attacks = len(self.board.attackers(chess.WHITE, black_king))
            king_safety_weight = 0.5 if total_material > 3000 else 1.0 if total_material > 1500 else 0.3
            king_safety_score += black_king_attacks * king_safety_weight
            if self.board.has_castling_rights(chess.BLACK):
                king_safety_score -= 1.0
                castling_bonus -= 1.5
            if total_material > 3000:
                file = chess.square_file(black_king)
                if 2 <= file <= 5:
                    king_safety_score += 1.0
            if total_material < 1500:
                rank = chess.square_rank(black_king)
                file = chess.square_file(black_king)
                king_activity_score -= (4 - abs(4 - rank) - abs(4 - file)) * 0.2

        if len(self.board.move_stack) < 10:
            for square in chess.SQUARES:
                piece = self.board.piece_at(square)
                if piece and piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                    rank = chess.square_rank(square)
                    if piece.color == chess.WHITE and rank > 1:
                        development_score += 1.0  # Tăng trọng số phát triển quân
                    elif piece.color == chess.BLACK and rank < 6:
                        development_score -= 1.0

        if len(self.board.move_stack) < 10:
            development_score += white_developed_pieces * 1.5  # Tăng trọng số phát triển quân
            development_score -= black_developed_pieces * 1.5

            if white_developed_pieces > black_developed_pieces + 1:
                passive_move_penalty -= 2.0  # Tăng phạt nếu không phát triển quân
            elif black_developed_pieces > white_developed_pieces + 1:
                passive_move_penalty += 2.0

            if white_center_control > black_center_control + 1:
                threat_score -= 2.0  # Tăng trọng số kiểm soát trung tâm
            elif black_center_control > white_center_control + 1:
                threat_score += 2.0

        eval_score = (material_score + position_score + center_control_score +
                      king_safety_score + pawn_structure_score + development_score +
                      mobility_score + threat_score + bishop_pair_bonus + rook_open_file_bonus +
                      passed_pawn_bonus + king_activity_score + outpost_score +
                      diagonal_control_score + pinned_piece_penalty + center_pawn_bonus +
                      passive_move_penalty + castling_bonus + exposed_piece_penalty)

        if self.bot_color == chess.BLACK:
            eval_score = -eval_score

        return eval_score

    def get_zobrist_hash(self):
        return chess.polyglot.zobrist_hash(self.board)

    def static_exchange_evaluation(self, move):
        if not self.board.is_capture(move):
            return 0

        square = move.to_square
        captured_piece = self.board.piece_at(square)
        if not captured_piece:
            return 0

        gain = self.piece_values[captured_piece.piece_type]
        moving_piece = self.board.piece_at(move.from_square)
        if not moving_piece:
            return 0

        self.board.push(move)
        attackers = []
        for attacker_square in self.board.attackers(not self.board.turn, square):
            attacker = self.board.piece_at(attacker_square)
            if attacker:
                attackers.append((self.piece_values[attacker.piece_type], attacker_square))
        for attacker_square in self.board.attackers(self.board.turn, square):
            attacker = self.board.piece_at(attacker_square)
            if attacker:
                attackers.append((self.piece_values[attacker.piece_type], attacker_square))
        self.board.pop()

        value = gain
        attackers.sort(key=lambda x: x[0])
        turn = not self.board.turn
        for i, (attacker_value, _) in enumerate(attackers):
            if i % 2 == (0 if turn == self.board.turn else 1):
                value -= attacker_value
            else:
                value += attacker_value
            if value < 0:
                break

        return max(0, value)

    def sort_moves(self, moves, depth):
        zobrist_hash = self.get_zobrist_hash()
        tt_move = None
        if zobrist_hash in self.transposition_table:
            tt_entry = self.transposition_table[zobrist_hash]
            if tt_entry[1] >= depth:
                tt_move = tt_entry[3]

        def move_score(move):
            score = 0
            if move == tt_move:
                score += 10000
            if self.board.is_capture(move):
                if self.board.is_en_passant(move):
                    score += 1000
                else:
                    # Sử dụng MVV-LVA (Most Valuable Victim - Least Valuable Attacker)
                    captured_piece = self.board.piece_at(move.to_square)
                    moving_piece = self.board.piece_at(move.from_square)
                    if captured_piece and moving_piece:
                        score += (self.piece_values[captured_piece.piece_type] * 10 -
                                 self.piece_values[moving_piece.piece_type])
            self.board.push(move)
            if self.board.is_check():
                score += 500
            self.board.pop()
            if depth in self.killer_moves and move in self.killer_moves[depth]:
                score += 2000
            move_key = (move.from_square, move.to_square)
            if move_key in self.history_table:
                score += self.history_table[move_key] // 10
            if len(self.board.move_stack) < 10:
                # Ưu tiên phát triển quân trong khai cuộc
                if move.from_square in [chess.B1, chess.G1, chess.C1, chess.F1] and self.board.turn == chess.WHITE:
                    score += 100
                if move.from_square in [chess.B8, chess.G8, chess.C8, chess.F8] and self.board.turn == chess.BLACK:
                    score += 100
                if move.to_square in [chess.D4, chess.D5, chess.E4, chess.E5]:
                    score += 150
            return score

        return sorted(moves, key=move_score, reverse=True)

    def quiescence_search(self, alpha, beta):
        stand_pat = self.evaluate_board()
        if stand_pat >= beta:
            return beta
        if alpha < stand_pat:
            alpha = stand_pat

        delta = 900
        if stand_pat < alpha - delta:
            return alpha

        moves = list(self.board.legal_moves)
        filtered_moves = []
        for move in moves:
            if self.board.gives_check(move):
                filtered_moves.append(move)
            elif self.board.is_capture(move):
                if self.board.is_en_passant(move):
                    filtered_moves.append(move)
                else:
                    see_score = self.static_exchange_evaluation(move)
                    if see_score > 0:
                        filtered_moves.append(move)
            elif self.board.piece_at(move.from_square) and self.board.piece_at(move.from_square).piece_type == chess.PAWN:
                rank = chess.square_rank(move.to_square)
                if (self.board.turn == chess.WHITE and rank >= 6) or (self.board.turn == chess.BLACK and rank <= 1):
                    filtered_moves.append(move)

        moves = self.sort_moves(filtered_moves, 0)

        for move in moves:
            self.board.push(move)
            score = -self.quiescence_search(-beta, -alpha)
            self.board.pop()

            if score >= beta:
                return beta
            if score > alpha:
                alpha = score

        return alpha

    def null_move_pruning(self, depth, beta):
        """Áp dụng Null Move Pruning để giảm số nhánh cần tìm kiếm."""
        if depth < 3 or self.board.is_check():
            return None

        has_big_piece = False
        for piece in self.board.piece_map().values():
            if piece.color == self.board.turn and piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]:
                has_big_piece = True
                break
        if not has_big_piece:
            return None

        self.board.push(chess.Move.null())
        score = -self.minimax(depth - 3, -beta, -beta + 1)
        self.board.pop()
        return score

    def minimax(self, depth, alpha, beta, allow_null_move=True):
        zobrist_hash = self.get_zobrist_hash()

        if zobrist_hash in self.transposition_table:
            tt_entry = self.transposition_table[zobrist_hash]
            tt_score, tt_depth, tt_flag, tt_move = tt_entry
            if tt_depth >= depth:
                if tt_flag == 0:
                    return tt_score
                if tt_flag == 1 and tt_score <= alpha:
                    return alpha
                if tt_flag == 2 and tt_score >= beta:
                    return beta

        if depth == 0:
            return self.quiescence_search(alpha, beta)

        if self.board.is_game_over():
            eval = self.evaluate_board()
            return eval

        # Null Move Pruning
        if allow_null_move:
            null_score = self.null_move_pruning(depth, beta)
            if null_score is not None and null_score >= beta:
                return beta

        moves = self.sort_moves(list(self.board.legal_moves), depth)
        if not moves:
            print(f"No legal moves at depth {depth}, board: {self.board.fen()}")
            return self.evaluate_board()

        move_count = 0
        best_score = float('-inf') if self.board.turn == self.bot_color else float('inf')
        best_move = None

        # Futility Pruning
        futility_margin = 150 if depth <= 2 else 300
        if depth <= 2 and not self.board.is_check():
            eval = self.evaluate_board()
            if eval + futility_margin <= alpha:
                return alpha

        # Search Extensions: Mở rộng độ sâu cho các nước đi kiểm tra Vua
        extension = 0
        if self.board.is_check():
            extension = 1

        if self.board.turn == self.bot_color:
            for move in moves:
                self.board.push(move)
                move_count += 1

                # Late Move Reductions (LMR)
                if move_count > 3 and depth >= 3 and not self.board.is_check() and not self.board.is_capture(move):
                    R = 1 if depth < 6 else 2
                    score = -self.minimax(depth - 1 - R + extension, -beta, -alpha, allow_null_move=False)
                    if score > alpha and score < beta:
                        score = -self.minimax(depth - 1 + extension, -beta, -alpha, allow_null_move=False)
                else:
                    score = -self.minimax(depth - 1 + extension, -beta, -alpha, allow_null_move=True)

                self.board.pop()
                if score > best_score:
                    best_score = score
                    best_move = move
                alpha = max(alpha, score)
                if beta <= alpha:
                    move_key = (move.from_square, move.to_square)
                    self.history_table[move_key] = self.history_table.get(move_key, 0) + depth * depth
                    if depth not in self.killer_moves:
                        self.killer_moves[depth] = []
                    if move not in self.killer_moves[depth]:
                        self.killer_moves[depth].append(move)
                        if len(self.killer_moves[depth]) > 2:
                            self.killer_moves[depth].pop(0)
                    break
        else:
            for move in moves:
                self.board.push(move)
                move_count += 1

                if move_count > 3 and depth >= 3 and not self.board.is_check() and not self.board.is_capture(move):
                    R = 1 if depth < 6 else 2
                    score = -self.minimax(depth - 1 - R + extension, -beta, -alpha, allow_null_move=False)
                    if score > alpha and score < beta:
                        score = -self.minimax(depth - 1 + extension, -beta, -alpha, allow_null_move=False)
                else:
                    score = -self.minimax(depth - 1 + extension, -beta, -alpha, allow_null_move=True)

                self.board.pop()
                if score < best_score:
                    best_score = score
                    best_move = move
                beta = min(beta, score)
                if beta <= alpha:
                    move_key = (move.from_square, move.to_square)
                    self.history_table[move_key] = self.history_table.get(move_key, 0) + depth * depth
                    if depth not in self.killer_moves:
                        self.killer_moves[depth] = []
                    if move not in self.killer_moves[depth]:
                        self.killer_moves[depth].append(move)
                        if len(self.killer_moves[depth]) > 2:
                            self.killer_moves[depth].pop(0)
                    break

        flag = 0
        if best_score <= alpha:
            flag = 1
        elif best_score >= beta:
            flag = 2
        self.transposition_table[zobrist_hash] = (best_score, depth, flag, best_move)

        return best_score

    def evaluate_move(self, move, depth, alpha, beta):
        board_copy = self.board.copy()
        if move not in board_copy.legal_moves:
            print(f"Move {move} is not legal in position {board_copy.fen()}")
            return float('-inf') if self.board.turn == self.bot_color else float('inf'), move
        board_copy.push(move)
        original_board = self.board
        self.board = board_copy
        value = self.minimax(depth - 1, alpha, beta)
        self.board = original_board
        return value, move

    def iterative_deepening(self, max_time):
        start_time = time.time()
        best_move = None
        depth = 1
        max_depth = 20

        self.killer_moves = defaultdict(list)
        self.history_table = defaultdict(int)

        manager = mp.Manager()
        shared_transposition_table = manager.dict()
        self.transposition_table = shared_transposition_table

        num_processes = mp.cpu_count()

        # Aspiration Window
        alpha = float('-inf')
        beta = float('inf')
        window = 50

        while time.time() - start_time < max_time and depth <= max_depth:
            best_value = float('-inf')
            current_best_move = None

            board_copy = self.board.copy()
            moves = list(board_copy.legal_moves)
            if not moves:
                print(f"No legal moves available at depth {depth}, board: {board_copy.fen()}")
                return None
            moves = self.sort_moves(moves, depth)

            chunk_size = max(1, len(moves) // num_processes)
            move_chunks = [moves[i:i + chunk_size] for i in range(0, len(moves), chunk_size)]

            with mp.Pool(processes=num_processes) as pool:
                results = []
                for chunk in move_chunks:
                    for move in chunk:
                        result = pool.apply_async(self.evaluate_move, args=(move, depth, alpha, beta))
                        results.append((move, result))

                for move, result in results:
                    value, _ = result.get()
                    if value > best_value:
                        best_value = value
                        current_best_move = move

            if best_value <= alpha or best_value >= beta:
                alpha = float('-inf')
                beta = float('inf')
                continue

            alpha = best_value - window
            beta = best_value + window
            window += 10

            best_move = current_best_move
            depth += 1

        if best_move and best_move.promotion is not None:
            best_move.promotion = chess.QUEEN

        if best_move is None and moves:
            best_move = random.choice(moves)
            print("Không tìm được nước đi tối ưu, chọn ngẫu nhiên:", best_move)

        print(f"Bot suy nghĩ trong {time.time() - start_time:.2f} giây, đạt độ sâu {depth - 1}.")
        return best_move