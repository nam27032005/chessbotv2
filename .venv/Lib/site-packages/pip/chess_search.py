import chess
import time
import random
import json
import os
from collections import defaultdict
from evaluation import Evaluation
from move_ordering import MoveOrdering
from transposition import TranspositionTable

class ZobristHasher:
    def __init__(self):
        self.zobrist_table = {}
        for square in range(64):
            for piece in range(12):
                self.zobrist_table[(square, piece)] = random.getrandbits(64)
        self.zobrist_side = random.getrandbits(64)
        self.zobrist_castling = [random.getrandbits(64) for _ in range(16)]
        self.zobrist_en_passant = [random.getrandbits(64) for _ in range(65)]

    def hash_board(self, board):
        h = 0
        for square in chess.SQUARES:
            piece = board.piece_at(square)
            if piece:
                piece_idx = (piece.piece_type - 1) + (6 if piece.color == chess.BLACK else 0)
                h ^= self.zobrist_table[(square, piece_idx)]
        if board.turn == chess.BLACK:
            h ^= self.zobrist_side
        castling_rights = 0
        if board.has_kingside_castling_rights(chess.WHITE):
            castling_rights |= 1
        if board.has_queenside_castling_rights(chess.WHITE):
            castling_rights |= 2
        if board.has_kingside_castling_rights(chess.BLACK):
            castling_rights |= 4
        if board.has_queenside_castling_rights(chess.BLACK):
            castling_rights |= 8
        h ^= self.zobrist_castling[castling_rights]
        if board.ep_square is not None:
            h ^= self.zobrist_en_passant[chess.square_file(board.ep_square)]
        else:
            h ^= self.zobrist_en_passant[64]
        return h

class ChessSearch:
    def __init__(self, board, bot_color, piece_values, pawn_table_opening=None, pawn_table_middlegame=None, pawn_table_endgame=None,
                 knight_table=None, bishop_table=None, rook_table=None, queen_table=None, king_table_opening=None,
                 king_table_endgame=None, use_nnue=True):
        self.board = board
        self.bot_color = bot_color
        self.piece_values = piece_values
        self.evaluation = Evaluation(
            board=board,
            piece_values=piece_values,
            pawn_table_opening=pawn_table_opening,
            pawn_table_middlegame=pawn_table_middlegame,
            pawn_table_endgame=pawn_table_endgame,
            knight_table=knight_table,
            bishop_table=bishop_table,
            rook_table=rook_table,
            queen_table=queen_table,
            king_table_opening=king_table_opening,
            king_table_endgame=king_table_endgame,
            use_nnue=use_nnue
        )
        self.move_ordering = MoveOrdering(board, piece_values)
        self.transposition_table = TranspositionTable()
        self.killer_moves = defaultdict(list)
        self.history_table = defaultdict(int)
        self.counter_move_table = {}
        self.pawn_structure_table = {}
        self.last_move = None
        self.opening_history = defaultdict(lambda: {"wins": 0, "losses": 0, "draws": 0, "count": 0})
        self.play_style = "balanced"
        self.zobrist_hasher = ZobristHasher()
        self.nodes_searched = 0
        self.start_time = None

    def evaluate_board(self):
        self.nodes_searched += 1
        return self.evaluation.evaluate_board()

    def get_zobrist_hash(self):
        return self.zobrist_hasher.hash_board(self.board)

    def null_move_pruning(self, depth, beta):
        if depth < 4 or self.board.is_check():
            return None

        has_big_piece = False
        for piece in self.board.piece_map().values():
            if piece.color == self.board.turn and piece.piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]:
                has_big_piece = True
                break
        if not has_big_piece:
            return None

        self.board.push(chess.Move.null())
        score = -self.minimax(depth - 4, -beta, -beta + 1)
        self.board.pop()
        return score

    def is_singular(self, move, depth, alpha, beta):
        if depth <= 1:
            return False

        margin = 50
        original_alpha = alpha
        alpha = alpha - margin
        beta = beta + margin

        self.board.push(move)
        original_eval = -self.minimax(depth - 2, -beta, -alpha)
        self.board.pop()

        if original_eval <= alpha:
            return False

        moves = list(self.board.legal_moves)
        moves.remove(move)
        best_score = float('-inf')

        for other_move in moves:
            self.board.push(other_move)
            score = -self.minimax(depth - 2, -beta, -alpha)
            self.board.pop()
            best_score = max(best_score, score)

        return original_eval >= best_score + margin

    def razoring(self, depth, alpha):
        if depth <= 3 and not self.board.is_check():
            eval = self.evaluate_board()
            if eval + 150 < alpha:
                return self.quiescence_search(alpha, alpha + 1)
        return None

    def futility_pruning(self, depth, alpha, beta):
        if depth <= 2 and not self.board.is_check():
            eval = self.evaluate_board()
            if eval + 200 <= alpha:
                return alpha
        return None

    def quiescence_search(self, alpha, beta):
        self.nodes_searched += 1
        stand_pat = self.evaluate_board()
        if stand_pat >= beta:
            return beta
        if alpha < stand_pat:
            alpha = stand_pat

        delta = 900 + max(self.piece_values.values())
        if stand_pat < alpha - delta:
            return alpha

        moves = list(self.board.legal_moves)
        filtered_moves = []
        total_material = self.evaluation.get_total_material()

        for move in moves:
            if self.board.gives_check(move):
                filtered_moves.append(move)
            elif self.board.is_capture(move):
                if self.board.is_en_passant(move):
                    filtered_moves.append(move)
                else:
                    captured_piece = self.board.piece_at(move.to_square)
                    if captured_piece:
                        see_score = self.move_ordering.static_exchange_evaluation(move)
                        if see_score >= 0:
                            filtered_moves.append(move)
            elif move.promotion:
                filtered_moves.append(move)
            elif total_material <= 1500:
                piece = self.board.piece_at(move.from_square)
                if piece:
                    if piece.piece_type == chess.PAWN:
                        rank = chess.square_rank(move.to_square)
                        if (self.board.turn == chess.WHITE and rank >= 6) or (self.board.turn == chess.BLACK and rank <= 1):
                            filtered_moves.append(move)
                    elif piece.piece_type == chess.KING:
                        filtered_moves.append(move)

        if not filtered_moves:
            return stand_pat

        moves = self.move_ordering.sort_moves(filtered_moves, 0, self.killer_moves, self.history_table, self.counter_move_table, self.last_move, self.transposition_table, self.zobrist_hasher)

        for move in moves:
            self.board.push(move)
            score = -self.quiescence_search(-beta, -alpha)
            self.board.pop()

            if score >= beta:
                return beta
            if score > alpha:
                alpha = score

        return alpha

    def minimax(self, depth, alpha, beta, allow_null_move=True, is_pv_node=True):
        self.nodes_searched += 1

        if self.start_time and time.time() - self.start_time >= 5.0:
            raise TimeoutError("Hết thời gian tìm kiếm")

        if self.board.can_claim_draw():
            return 0

        zobrist_hash = self.get_zobrist_hash()
        tt_entry = self.transposition_table.get(zobrist_hash, depth)
        if tt_entry:
            tt_score, tt_depth, tt_flag, tt_move = tt_entry
            if tt_depth >= depth:
                if tt_flag == 0:
                    return tt_score
                if tt_flag == 1 and tt_score <= alpha:
                    return alpha
                if tt_flag == 2 and tt_score >= beta:
                    return beta

        if depth == 0:
            return self.quiescence_search(alpha, beta)

        if self.board.is_game_over():
            eval = self.evaluate_board()
            return eval

        razor_score = self.razoring(depth, alpha)
        if razor_score is not None:
            return razor_score

        futility_score = self.futility_pruning(depth, alpha, beta)
        if futility_score is not None:
            return futility_score

        if allow_null_move:
            null_score = self.null_move_pruning(depth, beta)
            if null_score is not None and null_score >= beta:
                return beta

        moves = self.move_ordering.sort_moves(list(self.board.legal_moves), depth, self.killer_moves, self.history_table, self.counter_move_table, self.last_move, self.transposition_table, self.zobrist_hasher)
        if not moves:
            return self.evaluate_board()

        move_count = 0
        best_score = float('-inf') if self.board.turn == self.bot_color else float('inf')
        best_move = None

        extension = 0
        if self.board.is_check():
            extension = 1

        if self.board.turn == self.bot_color:
            for move in moves:
                self.board.push(move)
                move_count += 1

                singular_extension = 0
                if move_count == 1 and depth >= 8 and self.is_singular(move, depth, alpha, beta):
                    singular_extension = 1

                if move_count > 3 and depth >= 3 and not self.board.is_check() and not self.board.is_capture(move) and not move.promotion:
                    R = 1 if depth < 6 else 2
                    score = -self.minimax(depth - 1 - R + extension + singular_extension, -beta, -alpha, allow_null_move=False, is_pv_node=False)
                    if score > alpha and score < beta:
                        score = -self.minimax(depth - 1 + extension + singular_extension, -beta, -alpha, allow_null_move=False, is_pv_node=True)
                else:
                    if move_count == 1 or not is_pv_node:
                        score = -self.minimax(depth - 1 + extension + singular_extension, -beta, -alpha, allow_null_move=True, is_pv_node=True)
                    else:
                        score = -self.minimax(depth - 1 + extension + singular_extension, -alpha - 1, -alpha, allow_null_move=True, is_pv_node=False)
                        if score > alpha and score < beta:
                            score = -self.minimax(depth - 1 + extension + singular_extension, -beta, -alpha, allow_null_move=True, is_pv_node=True)

                self.board.pop()
                if score > best_score:
                    best_score = score
                    best_move = move

                    if self.last_move is not None:
                        last_from, last_to = self.last_move.from_square, self.last_move.to_square
                        if last_from not in self.counter_move_table:
                            self.counter_move_table[last_from] = {}
                        self.counter_move_table[last_from][last_to] = move

                alpha = max(alpha, score)
                if beta <= alpha:
                    move_key = (move.from_square, move.to_square)
                    self.history_table[move_key] = self.history_table.get(move_key, 0) + depth * depth
                    if depth not in self.killer_moves:
                        self.killer_moves[depth] = []
                    if move not in self.killer_moves[depth]:
                        self.killer_moves[depth].append(move)
                        if len(self.killer_moves[depth]) > 2:
                            self.killer_moves[depth].pop(0)
                    break
        else:
            for move in moves:
                self.board.push(move)
                move_count += 1

                singular_extension = 0
                if move_count == 1 and depth >= 8 and self.is_singular(move, depth, alpha, beta):
                    singular_extension = 1

                if move_count > 3 and depth >= 3 and not self.board.is_check() and not self.board.is_capture(move) and not move.promotion:
                    R = 1 if depth < 6 else 2
                    score = -self.minimax(depth - 1 - R + extension + singular_extension, -beta, -alpha, allow_null_move=False, is_pv_node=False)
                    if score > alpha and score < beta:
                        score = -self.minimax(depth - 1 + extension + singular_extension, -beta, -alpha, allow_null_move=False, is_pv_node=True)
                else:
                    if move_count == 1 or not is_pv_node:
                        score = -self.minimax(depth - 1 + extension + singular_extension, -beta, -alpha, allow_null_move=True, is_pv_node=True)
                    else:
                        score = -self.minimax(depth - 1 + extension + singular_extension, -alpha - 1, -alpha, allow_null_move=True, is_pv_node=False)
                        if score > alpha and score < beta:
                            score = -self.minimax(depth - 1 + extension + singular_extension, -beta, -alpha, allow_null_move=True, is_pv_node=True)

                self.board.pop()
                if score < best_score:
                    best_score = score
                    best_move = move

                    if self.last_move is not None:
                        last_from, last_to = self.last_move.from_square, self.last_move.to_square
                        if last_from not in self.counter_move_table:
                            self.counter_move_table[last_from] = {}
                        self.counter_move_table[last_from][last_to] = move

                beta = min(beta, score)
                if beta <= alpha:
                    move_key = (move.from_square, move.to_square)
                    self.history_table[move_key] = self.history_table.get(move_key, 0) + depth * depth
                    if depth not in self.killer_moves:
                        self.killer_moves[depth] = []
                    if move not in self.killer_moves[depth]:
                        self.killer_moves[depth].append(move)
                        if len(self.killer_moves[depth]) > 2:
                            self.killer_moves[depth].pop(0)
                    break

        flag = 0
        if best_score <= alpha:
            flag = 1
        elif best_score >= beta:
            flag = 2
        self.transposition_table.store(zobrist_hash, best_score, depth, flag, best_move)

        self.last_move = best_move
        return best_score

    def get_opening_move(self):
        if len(self.board.move_stack) >= 10:
            print("Đã vượt quá giới hạn khai cuộc (10 nước), chuyển sang tìm kiếm minimax.")
            return None

        opening_book_path = "opening.json"
        try:
            if not os.path.exists(opening_book_path):
                print(f"Không tìm thấy tệp opening book tại {opening_book_path}. Chuyển sang tìm kiếm minimax.")
                return None

            with open(opening_book_path, "r") as f:
                opening_book = json.load(f)

            fen = self.board.fen()
            if fen not in opening_book:
                print("Không tìm thấy vị trí hiện tại trong opening book, chuyển sang tìm kiếm minimax.")
                return None

            opening_moves_uci = opening_book[fen]
            if not opening_moves_uci:
                print("Không có nước đi khai cuộc nào cho vị trí này, chuyển sang tìm kiếm minimax.")
                return None

            legal_moves = list(self.board.legal_moves)
            opening_moves = []
            for move_uci in opening_moves_uci:
                move = chess.Move.from_uci(move_uci)
                if move in legal_moves:
                    opening_moves.append(move)

            if not opening_moves:
                print("Không có nước đi khai cuộc hợp lệ trong opening book, chuyển sang tìm kiếm minimax.")
                return None

            prioritized_moves = []
            for move in opening_moves:
                move_uci = move.uci()
                weight = 1.0
                if self.play_style == "aggressive":
                    if self.bot_color == chess.WHITE:
                        if move_uci in ["e2e4", "d2d4", "g1f3", "f2f4"]:
                            weight *= 1.5
                    else:
                        if move_uci in ["e7e5", "d7d5", "g8f6", "c7c5"]:
                            weight *= 1.5
                elif self.play_style == "defensive":
                    if self.bot_color == chess.WHITE:
                        if move_uci in ["c2c4", "e2e3"]:
                            weight *= 1.5
                    else:
                        if move_uci in ["e7e6", "d7d6"]:
                            weight *= 1.5
                elif self.play_style == "positional":
                    if self.bot_color == chess.WHITE:
                        if move_uci in ["d2d4", "c2c4", "g1f3"]:
                            weight *= 1.5
                    else:
                        if move_uci in ["d7d5", "e7e6", "g8f6"]:
                            weight *= 1.5

                opening_key = f"{self.board.fen()}:{move_uci}"
                if opening_key in self.opening_history:
                    stats = self.opening_history[opening_key]
                    if stats["count"] > 0:
                        win_rate = stats["wins"] / stats["count"]
                        weight *= (1 + win_rate)

                prioritized_moves.append((move, weight))

            if not prioritized_moves:
                print("Không có nước đi khai cuộc nào phù hợp sau khi ưu tiên, chuyển sang tìm kiếm minimax.")
                return None

            prioritized_moves.sort(key=lambda x: x[1], reverse=True)
            max_weight = prioritized_moves[0][1]
            top_moves = [move for move, weight in prioritized_moves if weight >= max_weight * 0.9]
            selected_move = random.choice(top_moves)
            print(f"Sử dụng nước đi từ Opening Book: {selected_move}")
            return selected_move

        except Exception as e:
            print(f"Lỗi khi đọc opening book: {e}. Chuyển sang tìm kiếm minimax.")
            return None

    def update_opening_history(self, opening_key, result):
        if result == "win":
            self.opening_history[opening_key]["wins"] += 1
        elif result == "loss":
            self.opening_history[opening_key]["losses"] += 1
        else:
            self.opening_history[opening_key]["draws"] += 1
        self.opening_history[opening_key]["count"] += 1

    def save_opening_history(self, filepath="opening_history.json"):
        with open(filepath, "w") as f:
            json.dump(self.opening_history, f)

    def load_opening_history(self, filepath="opening_history.json"):
        if os.path.exists(filepath):
            with open(filepath, "r") as f:
                self.opening_history = json.load(f)
                self.opening_history = defaultdict(lambda: {"wins": 0, "losses": 0, "draws": 0, "count": 0}, self.opening_history)

    def iterative_deepening(self, max_time):
        self.start_time = time.time()
        self.nodes_searched = 0
        best_move = None
        depth = 1
        max_depth = 20

        total_material = self.evaluation.get_total_material()
        if total_material > 1500:
            adjusted_max_time = max_time * 1.5
        else:
            adjusted_max_time = max_time * 0.8

        self.load_opening_history()

        opening_move = self.get_opening_move()
        if opening_move:
            opening_key = f"{self.board.fen()}:{opening_move.uci()}"
            return opening_move

        self.killer_moves = defaultdict(list)
        self.history_table = defaultdict(int)
        self.counter_move_table = {}
        self.pawn_structure_table = {}

        for square in chess.SQUARES:
            piece = self.board.piece_at(square)
            if piece and piece.piece_type == chess.PAWN:
                rank = chess.square_rank(square)
                if (piece.color == chess.WHITE and rank >= 6 and self.board.turn == chess.BLACK) or \
                   (piece.color == chess.BLACK and rank <= 1 and self.board.turn == chess.WHITE):
                    adjusted_max_time = max_time * 2
                    break

        board_copy = self.board.copy()
        moves = list(board_copy.legal_moves)
        if not moves:
            print(f"Không có nước đi hợp lệ tại độ sâu {depth}, bàn cờ: {board_copy.fen()}")
            return None
        moves = self.move_ordering.sort_moves(moves, depth, self.killer_moves, self.history_table, self.counter_move_table, self.last_move, self.transposition_table, self.zobrist_hasher)

        alpha = float('-inf')
        beta = float('inf')
        window = 25
        best_value = float('-inf')

        try:
            while depth <= max_depth:
                elapsed_time = time.time() - self.start_time
                if elapsed_time >= adjusted_max_time:
                    print(f"Thoát vòng lặp tại độ sâu {depth - 1} do vượt thời gian: {elapsed_time:.2f} giây")
                    break

                if depth > 1:
                    alpha = best_value - window
                    beta = best_value + window

                current_best_move = None
                for move in moves:
                    elapsed_time = time.time() - self.start_time
                    if elapsed_time >= adjusted_max_time:
                        print(f"Thoát vòng lặp tại độ sâu {depth - 1} do vượt thời gian: {elapsed_time:.2f} giây")
                        break

                    self.board.push(move)
                    score = -self.minimax(depth - 1, -beta, -alpha)
                    self.board.pop()
                    if score > best_value:
                        best_value = score
                        current_best_move = move
                    alpha = max(alpha, score)
                    if beta <= alpha:
                        break

                if elapsed_time >= adjusted_max_time:
                    break

                if best_value <= alpha or best_value >= beta:
                    alpha = float('-inf')
                    beta = float('inf')
                    window *= 2
                    continue

                alpha = best_value - window
                beta = best_value + window
                window = max(10, window // 2)

                best_move = current_best_move
                depth += 1

        except TimeoutError:
            print(f"Đã hết thời gian tìm kiếm tại độ sâu {depth - 1}")

        if best_move and best_move.promotion is not None:
            best_move.promotion = chess.QUEEN

        if best_move is None and moves:
            best_move = random.choice(moves)
            print("Không tìm được nước đi tối ưu, chọn ngẫu nhiên:", best_move)

        print(f"Bot suy nghĩ trong {time.time() - self.start_time:.2f} giây, đạt độ sâu {depth - 1}, duyệt {self.nodes_searched} node.")
        return best_move