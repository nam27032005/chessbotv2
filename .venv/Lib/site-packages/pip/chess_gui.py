import chess
import tkinter as tk
from tkinter import messagebox
from PIL import Image, ImageTk
import threading
import queue
import os
from chess_bot import ChessBot

class ChessGame:
    def __init__(self, root):
        self.root = root
        self.root.title("Chess Bot")
        self.board = chess.Board()
        self.selected_square = None
        self.piece_images = {}
        self.image_references = []
        self.bot_thinking = False
        self.bot_color = None
        self.player_color = None
        self.board_flipped = False
        self.move_queue = queue.Queue()
        self.bot = None  # Sẽ khởi tạo sau khi chọn màu

        # Khung chọn màu
        self.color_frame = tk.Frame(self.root)
        self.color_frame.pack(expand=True)

        self.game_frame = tk.Frame(self.root)

        self.board_frame = tk.Frame(self.game_frame)
        self.board_frame.pack(side=tk.LEFT, padx=10, pady=10)

        self.canvas = tk.Canvas(self.board_frame, width=480, height=480)
        self.canvas.pack()
        self.canvas.bind("<Button-1>", self.player_move)

        self.status_label = tk.Label(self.board_frame, text="", font=("Arial", 12))
        self.status_label.pack()

        self.choose_color()
        self.check_move_queue()

    def load_images(self):
        pieces = ['P', 'R', 'N', 'B', 'Q', 'K']
        colors = ['w', 'b']
        base_path = os.path.join(os.path.dirname(__file__), "pieces")
        print(f"Đường dẫn thư mục pieces: {base_path}")

        for color in colors:
            for piece in pieces:
                symbol = f"{color}{piece}"
                image_path = os.path.join(base_path, f"{symbol}.png")
                print(f"Đang thử tải: {image_path}")

                if not os.path.exists(image_path):
                    messagebox.showerror("Lỗi", f"Không tìm thấy file ảnh: {image_path}")
                    continue

                try:
                    image = Image.open(image_path)
                    image = image.resize((60, 60), Image.Resampling.LANCZOS)
                    photo = ImageTk.PhotoImage(image)
                    self.piece_images[symbol] = photo
                    self.image_references.append(photo)
                except Exception as e:
                    messagebox.showerror("Lỗi", f"Lỗi khi tải ảnh {image_path}: {e}")

    def bot_move(self):
        if not self.board.is_game_over() and not self.bot_thinking and self.board.turn == self.bot_color:
            self.bot_thinking = True
            self.status_label.config(text="Bot đang suy nghĩ")
            self.canvas.config(state="disabled")
            threading.Thread(target=self.bot_move_thread, daemon=True).start()

    def bot_move_thread(self):
        best_move = self.bot.get_best_move(self.board, max_time=3.0)
        self.move_queue.put(best_move)

    def check_move_queue(self):
        try:
            move = self.move_queue.get_nowait()
            self.apply_bot_move(move)
        except queue.Empty:
            pass
        finally:
            self.root.after(50, self.check_move_queue)

    def apply_bot_move(self, move):
        if move and self.bot_thinking:
            if move in self.board.legal_moves:
                self.board.push(move)
                self.update_board()
            else:
                print(f"Bot cố gắng đi nước không hợp lệ: {move}")
        self.bot_thinking = False
        self.status_label.config(text="")
        self.canvas.config(state="normal")
        if self.board.is_game_over():
            self.end_game()

    def update_board(self):
        self.canvas.delete("all")
        for square in chess.SQUARES:
            file = chess.square_file(square)
            rank = chess.square_rank(square)
            if self.board_flipped:
                display_file = 7 - file
                display_rank = rank
            else:
                display_file = file
                display_rank = 7 - rank
            color = "white" if (display_file + display_rank) % 2 == 0 else "gray"
            x1, y1 = display_file * 60, display_rank * 60
            self.canvas.create_rectangle(x1, y1, x1 + 60, y1 + 60, fill=color)

            piece = self.board.piece_at(square)
            if piece:
                piece_symbol = piece.symbol()
                color_prefix = 'w' if piece_symbol.isupper() else 'b'
                piece_type = piece_symbol.upper()
                image_key = f"{color_prefix}{piece_type}"
                if image_key in self.piece_images:
                    self.canvas.create_image(x1 + 30, y1 + 30, image=self.piece_images[image_key])

    def highlight_legal_moves(self, square):
        self.update_board()
        moves = [move for move in self.board.legal_moves if move.from_square == square]
        for move in moves:
            to_square = move.to_square
            file = chess.square_file(to_square)
            rank = chess.square_rank(to_square)
            if self.board_flipped:
                display_file = 7 - file
                display_rank = rank
            else:
                display_file = file
                display_rank = 7 - rank
            x1, y1 = display_file * 60, display_rank * 60
            self.canvas.create_rectangle(x1, y1, x1 + 60, y1 + 60, outline="yellow", width=2)

    def get_promotion_choice(self):
        promotion_window = tk.Toplevel(self.root)
        promotion_window.title("Chọn quân thăng cấp")
        promotion_window.geometry("200x200")
        promotion_window.grab_set()

        choice = tk.StringVar(value="q")
        tk.Button(promotion_window, text="Hậu", command=lambda: choice.set("q")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Xe", command=lambda: choice.set("r")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Tượng", command=lambda: choice.set("b")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Mã", command=lambda: choice.set("n")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Xác nhận", command=promotion_window.destroy).pack(pady=10)

        promotion_window.wait_window()
        piece_map = {"q": chess.QUEEN, "r": chess.ROOK, "b": chess.BISHOP, "n": chess.KNIGHT}
        return piece_map.get(choice.get(), chess.QUEEN)

    def player_move(self, event):
        if not self.board.is_game_over() and not self.bot_thinking and self.board.turn == self.player_color:
            x, y = event.x // 60, event.y // 60
            if not (0 <= x <= 7 and 0 <= y <= 7):
                return
            if self.board_flipped:
                file = 7 - x
                rank = y
            else:
                file = x
                rank = 7 - y
            square = chess.square(file, rank)

            if self.selected_square is None:
                if self.board.piece_at(square) and self.board.piece_at(square).color == self.board.turn:
                    self.selected_square = square
                    self.highlight_legal_moves(square)
            else:
                move = chess.Move(self.selected_square, square)

                if (self.board.piece_at(self.selected_square).piece_type == chess.PAWN and
                        (chess.square_rank(square) == 7 if self.board.turn == chess.WHITE else chess.square_rank(
                            square) == 0)):
                    promotion_choice = self.get_promotion_choice()
                    move = chess.Move(self.selected_square, square, promotion=promotion_choice)

                if move in self.board.legal_moves:
                    self.board.push(move)
                    self.update_board()
                    self.selected_square = None
                    if not self.board.is_game_over():
                        self.bot_move()
                    else:
                        self.end_game()
                else:
                    self.selected_square = None
                    self.update_board()

    def end_game(self):
        self.bot_thinking = False
        self.status_label.config(text="")
        result = self.board.result()
        if result == "1-0":
            messagebox.showinfo("Kết thúc ván cờ", "Trắng thắng!")
        elif result == "0-1":
            messagebox.showinfo("Kết thúc ván cờ", "Đen thắng!")
        else:
            messagebox.showinfo("Kết thúc ván cờ", "Hòa!")

    def choose_color(self):
        self.game_frame.pack_forget()
        self.color_frame.pack(expand=True)

        for widget in self.color_frame.winfo_children():
            widget.destroy()

        tk.Label(self.color_frame, text="Chọn màu của bạn", font=("Arial", 14)).pack(pady=10)
        self.choice = tk.StringVar(value="white")
        tk.Button(self.color_frame, text="Trắng", font=("Arial", 12),
                  command=lambda: self.choice.set("white")).pack(fill=tk.X, padx=50, pady=5)
        tk.Button(self.color_frame, text="Đen", font=("Arial", 12),
                  command=lambda: self.choice.set("black")).pack(fill=tk.X, padx=50, pady=5)
        tk.Button(self.color_frame, text="Xác nhận", font=("Arial", 12),
                  command=self.confirm_color).pack(pady=20)

    def confirm_color(self):
        if self.choice.get() == "white":
            self.player_color = chess.WHITE
            self.bot_color = chess.BLACK
            self.board_flipped = False
            self.bot = ChessBot(chess.BLACK)  # Khởi tạo bot với màu đen
        else:
            self.player_color = chess.BLACK
            self.bot_color = chess.WHITE
            self.board_flipped = True
            self.bot = ChessBot(chess.WHITE)  # Khởi tạo bot với màu trắng

        self.color_frame.pack_forget()
        self.game_frame.pack(expand=True)
        self.load_images()
        self.update_board()
        if self.bot_color == chess.WHITE:
            self.bot_move()