# chess_gui.py

import chess
import chess.pgn
import tkinter as tk
from tkinter import messagebox
from PIL import Image, ImageTk
import threading
import time
import os
import berserk
from chess_search import ChessSearch


class ChessGame:
    def __init__(self, root):
        self.root = root
        self.root.title("Chess Bot with Lichess Integration")
        self.board = chess.Board()
        self.move_stack = []
        self.selected_square = None
        self.piece_images = {}
        self.bot_thinking = False
        self.time_limit = 10.0
        self.player_time = self.time_limit
        self.bot_time = self.time_limit
        self.timer_running = False
        self.timer_start = 0
        self.current_timer_id = None
        self.bot_color = None
        self.player_color = None
        self.board_flipped = False
        self.lock = threading.Lock()
        self.bot_thread = None
        self.bot_thinking_animation_id = None
        self.move_history = []

        self.lichess_token = "your_new_token_here"
        try:
            print(f"Using token: {self.lichess_token}")
            self.lichess_client = berserk.Client(berserk.TokenSession(self.lichess_token))
            print("Successfully initialized Lichess client")
        except Exception as e:
            print(f"Failed to connect to Lichess: {e}")
            messagebox.showerror("Error", f"Failed to connect to Lichess: {e}")
            self.root.destroy()
            return

        self.load_images()

        self.color_frame = tk.Frame(self.root)
        self.color_frame.pack(expand=True)

        self.game_frame = tk.Frame(self.root)

        self.board_frame = tk.Frame(self.game_frame)
        self.board_frame.pack(side=tk.LEFT, padx=10, pady=10)

        self.canvas = tk.Canvas(self.board_frame, width=480, height=480)
        self.canvas.pack()
        self.canvas.bind("<Button-1>", self.player_move)

        self.status_label = tk.Label(self.board_frame, text="", font=("Arial", 12))
        self.status_label.pack()

        self.eval_label = tk.Label(self.board_frame, text="Evaluation: N/A", font=("Arial", 12))
        self.eval_label.pack()

        self.turn_label = tk.Label(self.board_frame, text="Turn: White", font=("Arial", 12))
        self.turn_label.pack()

        self.timer_label = tk.Label(self.board_frame, text="Player Time: 10s", font=("Arial", 12))
        self.timer_label.pack()

        self.button_frame = tk.Frame(self.board_frame)
        self.button_frame.pack()
        self.reset_button = tk.Button(self.button_frame, text="Reset", command=self.reset_board)
        self.reset_button.pack(side=tk.LEFT, padx=5)
        self.undo_button = tk.Button(self.button_frame, text="Undo", command=self.undo_move)
        self.undo_button.pack(side=tk.LEFT, padx=5)
        self.save_button = tk.Button(self.button_frame, text="Save Game", command=self.save_game)
        self.save_button.pack(side=tk.LEFT, padx=5)
        self.lichess_button = tk.Button(self.button_frame, text="Play on Lichess", command=self.play_on_lichess)
        self.lichess_button.pack(side=tk.LEFT, padx=5)

        self.depth_label = tk.Label(self.board_frame, text="Search Depth (1-20):", font=("Arial", 12))
        self.depth_label.pack()
        self.depth_scale = tk.Scale(self.board_frame, from_=1, to=20, orient=tk.HORIZONTAL)
        self.depth_scale.set(20)
        self.depth_scale.pack()

        self.history_frame = tk.Frame(self.game_frame)
        self.history_frame.pack(side=tk.RIGHT, padx=10, pady=10)

        self.history_label = tk.Label(self.history_frame, text="Move History", font=("Arial", 12))
        self.history_label.pack()

        self.history_listbox = tk.Listbox(self.history_frame, width=20, height=20, font=("Arial", 10))
        self.history_listbox.pack(side=tk.LEFT, fill=tk.Y)

        self.history_scrollbar = tk.Scrollbar(self.history_frame, orient=tk.VERTICAL)
        self.history_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.history_listbox.config(yscrollcommand=self.history_scrollbar.set)
        self.history_scrollbar.config(command=self.history_listbox.yview)

        self.choose_color()

    def load_images(self):
        pieces = ['P', 'R', 'N', 'B', 'Q', 'K']
        colors = ['w', 'b']
        for color in colors:
            for piece in pieces:
                symbol = f"{color}{piece}"
                image_path = f"C:/Users/ADMIN/PycharmProjects/chessbot/pieces/{symbol}.png"
                try:
                    image = Image.open(image_path)
                    image = image.resize((60, 60), Image.Resampling.LANCZOS)
                    self.piece_images[symbol] = ImageTk.PhotoImage(image)
                except FileNotFoundError:
                    messagebox.showerror("Error", f"Missing image file: {image_path}")
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to load image {image_path}: {e}")

    def bot_move(self):
        if not self.board.is_game_over() and not self.bot_thinking and self.board.turn == self.bot_color:
            with self.lock:
                self.bot_thinking = True
            self.status_label.config(text="Bot is thinking")
            self.bot_thinking_animation()
            self.canvas.config(state="disabled")
            self.root.update()
            self.bot_thread = threading.Thread(target=self.bot_move_thread, daemon=True)
            self.bot_thread.start()

    def bot_thinking_animation(self):
        if self.bot_thinking:
            current_text = self.status_label.cget("text")
            if current_text.endswith("..."):
                self.status_label.config(text="Bot is thinking")
            else:
                self.status_label.config(text=current_text + ".")
            self.bot_thinking_animation_id = self.root.after(500, self.bot_thinking_animation)

    def bot_move_thread(self):
        from constants import PIECE_VALUES, PAWN_TABLE_OPENING, PAWN_TABLE_MIDDLEGAME, PAWN_TABLE_ENDGAME, KNIGHT_TABLE, BISHOP_TABLE, ROOK_TABLE, QUEEN_TABLE, KING_TABLE_OPENING, KING_TABLE_ENDGAME
        searcher = ChessSearch(
            board=self.board,
            bot_color=self.bot_color,
            piece_values=PIECE_VALUES,
            pawn_table_opening=PAWN_TABLE_OPENING,
            pawn_table_middlegame=PAWN_TABLE_MIDDLEGAME,
            pawn_table_endgame=PAWN_TABLE_ENDGAME,
            knight_table=KNIGHT_TABLE,
            bishop_table=BISHOP_TABLE,
            rook_table=ROOK_TABLE,
            queen_table=QUEEN_TABLE,
            king_table_opening=KING_TABLE_OPENING,
            king_table_endgame=KING_TABLE_ENDGAME
        )
        best_move = searcher.iterative_deepening(max_time=5.0)
        self.root.after(0, lambda: self.apply_bot_move(best_move))

    def apply_bot_move(self, move):
        with self.lock:
            if move and self.bot_thinking:
                if move in self.board.legal_moves:
                    self.move_stack.append(self.board.fen())
                    san_move = self.board.san(move)
                    self.board.push(move)
                    self.update_board()
                    from constants import PIECE_VALUES, PAWN_TABLE_OPENING, PAWN_TABLE_MIDDLEGAME, PAWN_TABLE_ENDGAME, KNIGHT_TABLE, BISHOP_TABLE, ROOK_TABLE, QUEEN_TABLE, KING_TABLE_OPENING, KING_TABLE_ENDGAME
                    searcher = ChessSearch(
                        board=self.board,
                        bot_color=self.bot_color,
                        piece_values=PIECE_VALUES,
                        pawn_table_opening=PAWN_TABLE_OPENING,
                        pawn_table_middlegame=PAWN_TABLE_MIDDLEGAME,
                        pawn_table_endgame=PAWN_TABLE_ENDGAME,
                        knight_table=KNIGHT_TABLE,
                        bishop_table=BISHOP_TABLE,
                        rook_table=ROOK_TABLE,
                        queen_table=QUEEN_TABLE,
                        king_table_opening=KING_TABLE_OPENING,
                        king_table_endgame=KING_TABLE_ENDGAME
                    )
                    eval = searcher.evaluate_board()
                    if eval == float('inf'):
                        eval_text = "Mate"
                    elif eval == -float('inf'):
                        eval_text = "-Mate"
                    else:
                        eval_text = f"{eval / 100:.2f}"
                    self.eval_label.config(text=f"Evaluation: {eval_text}")
                    move_number = (len(self.move_history) // 2) + 1
                    if self.board.turn == chess.WHITE:
                        self.move_history.append(f"{move_number}. ... {san_move}")
                    else:
                        self.move_history.append(f"{move_number}. {san_move}")
                    self.history_listbox.delete(0, tk.END)
                    for move in self.move_history:
                        self.history_listbox.insert(tk.END, move)
                    self.history_listbox.yview(tk.END)
                else:
                    print(f"Invalid move attempted by bot: {move}")
            self.bot_thinking = False
        if self.bot_thinking_animation_id:
            self.root.after_cancel(self.bot_thinking_animation_id)
        self.status_label.config(text="")
        self.canvas.config(state="normal")
        self.bot_time = self.time_limit
        self.start_timer()
        if self.board.is_game_over():
            self.end_game()
        else:
            self.update_turn_label()

    def play_on_lichess(self):
        self.game_frame.pack_forget()
        self.status_label.config(text="Connecting to Lichess...")
        self.root.update()
        threading.Thread(target=self.lichess_game_loop, daemon=True).start()

    def lichess_game_loop(self):
        try:
            for event in self.lichess_client.bots.stream_incoming_events():
                if event['type'] == 'challenge':
                    challenge_id = event['challenge']['id']
                    self.lichess_client.bots.accept_challenge(challenge_id)
                    print(f"Accepted challenge: {challenge_id}")
                elif event['type'] == 'gameStart':
                    game_id = event['game']['id']
                    self.play_lichess_game(game_id)
        except Exception as e:
            print(f"Lichess error: {e}")
            self.root.after(0, lambda: self.status_label.config(text=f"Lichess error: {e}"))

    def play_lichess_game(self, game_id):
        try:
            game_stream = self.lichess_client.bots.stream_game_state(game_id)
            for event in game_stream:
                if event['type'] == 'gameFull':
                    self.board = chess.Board(event['state']['fen'])
                    if event['white']['id'] == self.lichess_client.account.get()['id']:
                        my_color = chess.WHITE
                    else:
                        my_color = chess.BLACK
                    if self.board.turn == my_color:
                        from constants import PIECE_VALUES, PAWN_TABLE_OPENING, PAWN_TABLE_MIDDLEGAME, PAWN_TABLE_ENDGAME, KNIGHT_TABLE, BISHOP_TABLE, ROOK_TABLE, QUEEN_TABLE, KING_TABLE_OPENING, KING_TABLE_ENDGAME
                        searcher = ChessSearch(
                            board=self.board,
                            bot_color=self.bot_color,
                            piece_values=PIECE_VALUES,
                            pawn_table_opening=PAWN_TABLE_OPENING,
                            pawn_table_middlegame=PAWN_TABLE_MIDDLEGAME,
                            pawn_table_endgame=PAWN_TABLE_ENDGAME,
                            knight_table=KNIGHT_TABLE,
                            bishop_table=BISHOP_TABLE,
                            rook_table=ROOK_TABLE,
                            queen_table=QUEEN_TABLE,
                            king_table_opening=KING_TABLE_OPENING,
                            king_table_endgame=KING_TABLE_ENDGAME
                        )
                        move = searcher.iterative_deepening(max_time=5.0)
                        self.lichess_client.bots.make_move(game_id, move.uci())
                elif event['type'] == 'gameState':
                    self.board = chess.Board(event['fen'])
                    if self.board.turn == my_color:
                        from constants import PIECE_VALUES, PAWN_TABLE_OPENING, PAWN_TABLE_MIDDLEGAME, PAWN_TABLE_ENDGAME, KNIGHT_TABLE, BISHOP_TABLE, ROOK_TABLE, QUEEN_TABLE, KING_TABLE_OPENING, KING_TABLE_ENDGAME
                        searcher = ChessSearch(
                            board=self.board,
                            bot_color=self.bot_color,
                            piece_values=PIECE_VALUES,
                            pawn_table_opening=PAWN_TABLE_OPENING,
                            pawn_table_middlegame=PAWN_TABLE_MIDDLEGAME,
                            pawn_table_endgame=PAWN_TABLE_ENDGAME,
                            knight_table=KNIGHT_TABLE,
                            bishop_table=BISHOP_TABLE,
                            rook_table=ROOK_TABLE,
                            queen_table=QUEEN_TABLE,
                            king_table_opening=KING_TABLE_OPENING,
                            king_table_endgame=KING_TABLE_ENDGAME
                        )
                        move = searcher.iterative_deepening(max_time=5.0)
                        self.lichess_client.bots.make_move(game_id, move.uci())
                elif event['type'] == 'gameFinish':
                    print(f"Game finished: {event['status']}")
                    self.root.after(0, lambda: self.status_label.config(text=f"Game finished: {event['status']}"))
                    break
        except Exception as e:
            print(f"Error in play_lichess_game: {e}")
            self.root.after(0, lambda: self.status_label.config(text=f"Error in play_lichess_game: {e}"))

    def reset_board(self):
        with self.lock:
            self.bot_thinking = False
        self.stop_timer()

        if self.bot_thread and self.bot_thread.is_alive():
            self.bot_thread.join()

        self.board = chess.Board()
        self.move_stack = []
        self.move_history = []
        self.history_listbox.delete(0, tk.END)
        self.selected_square = None
        self.status_label.config(text="")
        self.eval_label.config(text="Evaluation: N/A")
        self.timer_label.config(text="Player Time: 10s")
        self.game_frame.pack_forget()
        self.choose_color()

    def undo_move(self):
        if not self.bot_thinking and len(self.move_stack) > 0:
            self.board.pop()
            self.move_stack.pop()
            if self.bot_color == self.player_color:
                if len(self.move_stack) > 0:
                    self.board.pop()
                    self.move_stack.pop()
            self.move_history.pop()
            if self.bot_color == self.player_color and len(self.move_history) > 0:
                self.move_history.pop()
            self.history_listbox.delete(0, tk.END)
            for move in self.move_history:
                self.history_listbox.insert(tk.END, move)
            self.history_listbox.yview(tk.END)
            self.update_board()
            self.update_turn_label()
            self.status_label.config(text="Move undone")
            from constants import PIECE_VALUES, PAWN_TABLE_OPENING, PAWN_TABLE_MIDDLEGAME, PAWN_TABLE_ENDGAME, KNIGHT_TABLE, BISHOP_TABLE, ROOK_TABLE, QUEEN_TABLE, KING_TABLE_OPENING, KING_TABLE_ENDGAME
            searcher = ChessSearch(
                board=self.board,
                bot_color=self.bot_color,
                piece_values=PIECE_VALUES,
                pawn_table_opening=PAWN_TABLE_OPENING,
                pawn_table_middlegame=PAWN_TABLE_MIDDLEGAME,
                pawn_table_endgame=PAWN_TABLE_ENDGAME,
                knight_table=KNIGHT_TABLE,
                bishop_table=BISHOP_TABLE,
                rook_table=ROOK_TABLE,
                queen_table=QUEEN_TABLE,
                king_table_opening=KING_TABLE_OPENING,
                king_table_endgame=KING_TABLE_ENDGAME
            )
            eval = searcher.evaluate_board()
            if eval == float('inf'):
                eval_text = "Mate"
            elif eval == -float('inf'):
                eval_text = "-Mate"
            else:
                eval_text = f"{eval / 100:.2f}"
            self.eval_label.config(text=f"Evaluation: {eval_text}")

    def save_game(self):
        if not self.board.is_game_over():
            messagebox.showinfo("Info", "Game is not finished yet. Please finish the game to save.")
            return
        game = chess.pgn.Game.from_board(self.board)
        game.headers["Event"] = "Chess Bot Game"
        game.headers["White"] = "Player" if self.player_color == chess.WHITE else "Bot"
        game.headers["Black"] = "Bot" if self.player_color == chess.WHITE else "Player"
        game.headers["Date"] = time.strftime("%Y.%m.%d")
        game.headers["Result"] = self.board.result()
        with open("game.pgn", "w") as f:
            print(game, file=f)
        messagebox.showinfo("Info", "Game saved as game.pgn")

    def stop_timer(self):
        self.timer_running = False
        if self.current_timer_id is not None:
            self.root.after_cancel(self.current_timer_id)
            self.current_timer_id = None

    def start_timer(self):
        if not self.board.is_game_over():
            self.stop_timer()
            self.timer_running = True
            if self.board.turn == self.player_color:
                self.player_time = self.time_limit
                self.timer_label.config(text=f"Player Time: {self.player_time:.1f}s")
            else:
                self.bot_time = self.time_limit
                self.timer_label.config(text=f"Bot Time: {self.bot_time:.1f}s")
            self.timer_start = time.time()
            self.update_timer()

    def update_timer(self):
        if not self.timer_running or self.board.is_game_over():
            return

        elapsed = time.time() - self.timer_start
        if self.board.turn == self.player_color and not self.bot_thinking:
            self.player_time = max(0, self.time_limit - elapsed)
            if self.player_time <= 0:
                self.stop_timer()
                self.status_label.config(text="")
                self.timer_label.config(text="Player Time: 0s")
                messagebox.showinfo("Game Over", "Player ran out of time! Bot wins!")
                self.reset_board()
                return
            self.timer_label.config(text=f"Player Time: {self.player_time:.1f}s")
        elif self.board.turn == self.bot_color and self.bot_thinking:
            self.bot_time = max(0, self.time_limit - elapsed)
            if self.bot_time <= 0:
                self.stop_timer()
                self.status_label.config(text="")
                self.timer_label.config(text="Bot Time: 0s")
                messagebox.showinfo("Game Over", "Bot ran out of time! Player wins!")
                self.reset_board()
                return
            self.timer_label.config(text=f"Bot Time: {self.bot_time:.1f}s")

        if self.timer_running:
            self.current_timer_id = self.root.after(100, self.update_timer)

    def update_board(self):
        self.canvas.delete("all")
        for square in chess.SQUARES:
            file = chess.square_file(square)
            rank = chess.square_rank(square)
            if self.board_flipped:
                display_file = 7 - file
                display_rank = rank
            else:
                display_file = file
                display_rank = 7 - rank
            color = "white" if (display_file + display_rank) % 2 == 0 else "gray"
            x1, y1 = display_file * 60, display_rank * 60
            self.canvas.create_rectangle(x1, y1, x1 + 60, y1 + 60, fill=color)

            piece = self.board.piece_at(square)
            if piece:
                piece_symbol = piece.symbol()
                color_prefix = 'w' if piece_symbol.isupper() else 'b'
                piece_type = piece_symbol.upper()
                image_key = f"{color_prefix}{piece_type}"
                if image_key in self.piece_images:
                    self.canvas.create_image(x1 + 30, y1 + 30, image=self.piece_images[image_key])
                else:
                    print(f"Warning: Image for {image_key} not loaded")

    def highlight_legal_moves(self, square):
        self.update_board()
        moves = [move for move in self.board.legal_moves if move.from_square == square]
        for move in moves:
            to_square = move.to_square
            file = chess.square_file(to_square)
            rank = chess.square_rank(to_square)
            if self.board_flipped:
                display_file = 7 - file
                display_rank = rank
            else:
                display_file = file
                display_rank = 7 - rank
            x1, y1 = display_file * 60, display_rank * 60
            self.canvas.create_rectangle(x1, y1, x1 + 60, y1 + 60, outline="yellow", width=2)

    def update_turn_label(self):
        turn = "White" if self.board.turn == chess.WHITE else "Black"
        self.turn_label.config(text=f"Turn: {turn}")

    def get_promotion_choice(self):
        promotion_window = tk.Toplevel(self.root)
        promotion_window.title("Choose Promotion Piece")
        promotion_window.geometry("200x200")
        promotion_window.grab_set()

        choice = tk.StringVar(value="q")
        tk.Button(promotion_window, text="Queen", command=lambda: choice.set("q")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Rook", command=lambda: choice.set("r")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Bishop", command=lambda: choice.set("b")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Knight", command=lambda: choice.set("n")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Confirm", command=promotion_window.destroy).pack(pady=10)

        promotion_window.wait_window()
        piece_map = {"q": chess.QUEEN, "r": chess.ROOK, "b": chess.BISHOP, "n": chess.KNIGHT}
        return piece_map.get(choice.get(), chess.QUEEN)

    def player_move(self, event):
        if not self.board.is_game_over() and not self.bot_thinking and self.board.turn == self.player_color:
            x, y = event.x // 60, event.y // 60
            if not (0 <= x <= 7 and 0 <= y <= 7):
                return
            if self.board_flipped:
                file = 7 - x
                rank = y
            else:
                file = x
                rank = 7 - y
            square = chess.square(file, rank)

            if self.selected_square is None:
                if self.board.piece_at(square) and self.board.piece_at(square).color == self.board.turn:
                    self.selected_square = square
                    self.highlight_legal_moves(square)
            else:
                move = chess.Move(self.selected_square, square)

                if (self.board.piece_at(self.selected_square).piece_type == chess.PAWN and
                        (chess.square_rank(square) == 7 if self.board.turn == chess.WHITE else chess.square_rank(
                            square) == 0)):
                    promotion_choice = self.get_promotion_choice()
                    move = chess.Move(self.selected_square, square, promotion=promotion_choice)

                if move in self.board.legal_moves:
                    self.move_stack.append(self.board.fen())
                    san_move = self.board.san(move)
                    self.board.push(move)
                    self.update_board()
                    self.selected_square = None
                    self.player_time = self.time_limit
                    self.start_timer()
                    move_number = (len(self.move_history) // 2) + 1
                    if self.board.turn == chess.BLACK:
                        self.move_history.append(f"{move_number}. {san_move}")
                    else:
                        self.move_history.append(f"{move_number}. ... {san_move}")
                    self.history_listbox.delete(0, tk.END)
                    for move in self.move_history:
                        self.history_listbox.insert(tk.END, move)
                    self.history_listbox.yview(tk.END)
                    if not self.board.is_game_over():
                        self.bot_move()
                    else:
                        self.end_game()
                else:
                    self.selected_square = None
                    self.update_board()
                self.update_turn_label()

    def end_game(self):
        self.bot_thinking = False
        self.timer_running = False
        self.status_label.config(text="")
        self.timer_label.config(text="")
        result = self.board.result()
        if result == "1-0":
            messagebox.showinfo("Game Over", "White wins!")
        elif result == "0-1":
            messagebox.showinfo("Game Over", "Black wins!")
        else:
            messagebox.showinfo("Game Over", "Draw!")

    def choose_color(self):
        self.game_frame.pack_forget()
        self.color_frame.pack(expand=True)

        for widget in self.color_frame.winfo_children():
            widget.destroy()

        tk.Label(self.color_frame, text="Choose Your Color", font=("Arial", 14)).pack(pady=10)
        self.choice = tk.StringVar(value="white")
        tk.Button(self.color_frame, text="White", font=("Arial", 12),
                  command=lambda: self.choice.set("white")).pack(fill=tk.X, padx=50, pady=5)
        tk.Button(self.color_frame, text="Black", font=("Arial", 12),
                  command=lambda: self.choice.set("black")).pack(fill=tk.X, padx=50, pady=5)
        tk.Button(self.color_frame, text="Confirm", font=("Arial", 12),
                  command=self.confirm_color).pack(pady=20)

    def confirm_color(self):
        if self.choice.get() == "white":
            self.player_color = chess.WHITE
            self.bot_color = chess.BLACK
            self.board_flipped = False
        else:
            self.player_color = chess.BLACK
            self.bot_color = chess.WHITE
            self.board_flipped = True

        self.color_frame.pack_forget()
        self.game_frame.pack(expand=True)
        self.update_board()
        if self.bot_color == chess.WHITE:
            self.bot_move()