import chess
import chess.pgn
import tkinter as tk
from tkinter import messagebox
from PIL import Image, ImageTk
import threading
import time
import queue
import os
import json
from chess_search import ChessSearch


class OpeningDisplay:
    def __init__(self, json_path):
        self.openings = []
        print(f"Đang thử tải file từ đường dẫn: {json_path}")
        if not os.path.exists(json_path):
            print(f"Lỗi: File {json_path} không tồn tại. Vui lòng kiểm tra đường dẫn.")
            return
        try:
            with open(json_path, 'r', encoding='utf-8-sig') as f:
                self.openings = json.load(f)
            print(f"Đã tải opening book với {len(self.openings)} khai cuộc")
            print(f"Dữ liệu từ opening.json: {[entry['move_sequence'] for entry in self.openings[:5]]}")
        except json.JSONDecodeError as e:
            print(f"Lỗi: File {json_path} chứa JSON không hợp lệ: {e}")
            self.openings = []
        except Exception as e:
            print(f"Lỗi khi tải file JSON: {e}")
            self.openings = []
        self.board = chess.Board()
        self.current_opening = self.get_opening_name(self.board)

    def get_opening_name(self, board):
        # Lấy lịch sử nước đi ở dạng SAN
        move_stack = []
        board_copy = board.copy()
        while board_copy.move_stack:
            move = board_copy.pop()
            move_stack.insert(0, board_copy.san(move))
        print(f"Lịch sử nước đi: {move_stack}")

        # Tìm khai cuộc khớp với lịch sử nước đi
        for opening in self.openings:
            if opening["move_sequence"] == move_stack:
                print(f"Tìm thấy khai cuộc: {opening['opening_name']}")
                return opening["opening_name"]

        print("Không tìm thấy khai cuộc trong dữ liệu. Sử dụng mặc định.")
        return "Vị trí khởi đầu"

    def get_next_move(self, board):
        # Lấy lịch sử nước đi ở dạng SAN
        move_stack = []
        board_copy = board.copy()
        while board_copy.move_stack:
            move = board_copy.pop()
            move_stack.insert(0, board_copy.san(move))
        print(f"Lịch sử nước đi: {move_stack}")

        # Tìm khai cuộc khớp với lịch sử nước đi
        for opening in self.openings:
            if opening["move_sequence"] == move_stack:
                print(f"Tìm thấy khai cuộc: {opening['opening_name']}")
                next_moves = opening["next_moves"]
                if not next_moves:
                    print("Không có nước đi tiếp theo trong opening book.")
                    return None
                best_move_san = max(next_moves, key=lambda x: x["frequency"])["move"]
                print(f"Chọn nước đi SAN: {best_move_san}")
                board_copy = board.copy()
                for move in board_copy.legal_moves:
                    if board_copy.san(move) == best_move_san:
                        print(f"Tìm thấy nước đi hợp lệ: {move}")
                        return move
                print(f"Không tìm thấy nước đi hợp lệ cho SAN: {best_move_san}")
                return None

        print(f"Không tìm thấy khai cuộc cho lịch sử nước đi: {move_stack}. Chuyển sang minimax.")
        return None


class ChessGame:
    def __init__(self, root):
        self.root = root
        self.root.title("Chess Bot")
        self.board = chess.Board()
        self.move_stack = []
        self.selected_square = None
        self.piece_images = {}
        self.bot_thinking = False
        self.time_limit = 10.0
        self.player_time = self.time_limit
        self.bot_time = self.time_limit
        self.timer_running = False
        self.timer_start = 0
        self.current_timer_id = None
        self.bot_color = None
        self.player_color = None
        self.board_flipped = False
        self.move_history = []
        self.move_queue = queue.Queue()

        json_path = os.path.join(os.path.dirname(__file__), "opening.json")
        self.opening_display = OpeningDisplay(json_path)

        self.load_images()

        self.color_frame = tk.Frame(self.root)
        self.color_frame.pack(expand=True)

        self.game_frame = tk.Frame(self.root)

        self.board_frame = tk.Frame(self.game_frame)
        self.board_frame.pack(side=tk.LEFT, padx=10, pady=10)

        self.canvas = tk.Canvas(self.board_frame, width=480, height=480)
        self.canvas.pack()
        self.canvas.bind("<Button-1>", self.player_move)

        self.status_label = tk.Label(self.board_frame, text="", font=("Arial", 12))
        self.status_label.pack()

        self.bot_move_label = tk.Label(self.board_frame, text="Nước đi của Bot: N/A", font=("Arial", 12))
        self.bot_move_label.pack()

        self.eval_label = tk.Label(self.board_frame, text="Đánh giá: N/A", font=("Arial", 12))
        self.eval_label.pack()

        self.turn_label = tk.Label(self.board_frame, text="Lượt: Trắng", font=("Arial", 12))
        self.turn_label.pack()

        self.opening_label = tk.Label(self.board_frame, text="Khai cuộc: Vị trí khởi đầu", font=("Arial", 12))
        self.opening_label.pack()

        opening_name = self.opening_display.current_opening
        self.opening_label.config(text=f"Khai cuộc: {opening_name}")

        self.timer_label = tk.Label(self.board_frame, text="Thời gian người chơi: 10s", font=("Arial", 12))
        self.timer_label.pack()

        self.button_frame = tk.Frame(self.board_frame)
        self.button_frame.pack()
        self.reset_button = tk.Button(self.button_frame, text="Đặt lại", command=self.reset_board)
        self.reset_button.pack(side=tk.LEFT, padx=5)
        self.undo_button = tk.Button(self.button_frame, text="Hoàn tác", command=self.undo_move)
        self.undo_button.pack(side=tk.LEFT, padx=5)
        self.save_button = tk.Button(self.button_frame, text="Lưu ván cờ", command=self.save_game)
        self.save_button.pack(side=tk.LEFT, padx=5)

        self.depth_label = tk.Label(self.board_frame, text="Độ sâu tìm kiếm (1-20):", font=("Arial", 12))
        self.depth_label.pack()
        self.depth_scale = tk.Scale(self.board_frame, from_=1, to=20, orient=tk.HORIZONTAL)
        self.depth_scale.set(20)
        self.depth_scale.pack()

        self.history_frame = tk.Frame(self.game_frame)
        self.history_frame.pack(side=tk.RIGHT, padx=10, pady=10)

        self.history_label = tk.Label(self.history_frame, text="Lịch sử nước đi", font=("Arial", 12))
        self.history_label.pack()

        self.history_listbox = tk.Listbox(self.history_frame, width=20, height=20, font=("Arial", 10))
        self.history_listbox.pack(side=tk.LEFT, fill=tk.Y)

        self.history_scrollbar = tk.Scrollbar(self.history_frame, orient=tk.VERTICAL)
        self.history_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.history_listbox.config(yscrollcommand=self.history_scrollbar.set)
        self.history_scrollbar.config(command=self.history_listbox.yview)

        self.choose_color()
        self.check_move_queue()

    def load_images(self):
        pieces = ['P', 'R', 'N', 'B', 'Q', 'K']
        colors = ['w', 'b']
        for color in colors:
            for piece in pieces:
                symbol = f"{color}{piece}"
                image_path = os.path.join(os.path.dirname(__file__), "pieces", f"{symbol}.png")
                print(f"Đang thử tải ảnh: {image_path}")
                try:
                    image = Image.open(image_path)
                    image = image.resize((60, 60), Image.Resampling.LANCZOS)
                    self.piece_images[symbol] = ImageTk.PhotoImage(image)
                except FileNotFoundError:
                    messagebox.showerror("Lỗi", f"Không tìm thấy file ảnh: {image_path}")
                except Exception as e:
                    messagebox.showerror("Lỗi", f"Lỗi khi tải ảnh {image_path}: {e}")

    def bot_move(self):
        if not self.board.is_game_over() and not self.bot_thinking and self.board.turn == self.bot_color:
            self.bot_thinking = True
            self.status_label.config(text="Bot đang suy nghĩ")
            self.bot_move_label.config(text="Nước đi của Bot: N/A")
            self.bot_thinking_animation()
            self.canvas.config(state="disabled")
            threading.Thread(target=self.bot_move_thread, daemon=True).start()

    def bot_thinking_animation(self):
        if self.bot_thinking:
            current_text = self.status_label.cget("text")
            if current_text.endswith("..."):
                self.status_label.config(text="Bot đang suy nghĩ")
            else:
                self.status_label.config(text=current_text + ".")
            self.root.after(500, self.bot_thinking_animation)

    def bot_move_thread(self):
        from constants import PIECE_VALUES, PAWN_TABLE_OPENING, PAWN_TABLE_MIDDLEGAME, PAWN_TABLE_ENDGAME, KNIGHT_TABLE, \
            BISHOP_TABLE, ROOK_TABLE, QUEEN_TABLE, KING_TABLE_OPENING, KING_TABLE_ENDGAME
        searcher = ChessSearch(
            board=self.board.copy(),
            bot_color=self.bot_color,
            piece_values=PIECE_VALUES,
            pawn_table_opening=PAWN_TABLE_OPENING,
            pawn_table_middlegame=PAWN_TABLE_MIDDLEGAME,
            pawn_table_endgame=PAWN_TABLE_ENDGAME,
            knight_table=KNIGHT_TABLE,
            bishop_table=BISHOP_TABLE,
            rook_table=ROOK_TABLE,
            queen_table=QUEEN_TABLE,
            king_table_opening=KING_TABLE_OPENING,
            king_table_endgame=KING_TABLE_ENDGAME
        )
        opening_move = self.opening_display.get_next_move(self.board)
        if opening_move and opening_move in self.board.legal_moves:
            best_move = opening_move
        else:
            best_move = searcher.iterative_deepening(max_time=10.0)
            if not best_move:
                legal_moves = list(self.board.legal_moves)
                developing_moves = []
                for move in legal_moves:
                    move_str = self.board.san(move)
                    if move_str in ["Nf3", "Nc3", "e4", "d4", "c4", "Nf6", "Nc6", "e5", "d5", "c5"]:
                        developing_moves.append(move)
                best_move = developing_moves[0] if developing_moves else legal_moves[0]
        self.move_queue.put((best_move, searcher))

    def check_move_queue(self):
        try:
            best_move, searcher = self.move_queue.get_nowait()
            self.apply_bot_move(best_move, searcher)
        except queue.Empty:
            pass
        finally:
            self.root.after(100, self.check_move_queue)

    def apply_bot_move(self, move, searcher):
        if move and self.bot_thinking:
            if move in self.board.legal_moves:
                self.move_stack.append(self.board.fen())
                san_move = self.board.san(move)
                self.board.push(move)
                self.update_board()
                eval = searcher.evaluate_board()
                eval_text = "Chiếu hết" if eval == float('inf') else "-Chiếu hết" if eval == -float(
                    'inf') else f"{eval / 100:.2f}"
                self.eval_label.config(text=f"Đánh giá: {eval_text}")
                self.bot_move_label.config(text=f"Nước đi của Bot: {san_move}")
                move_number = (len(self.move_history) // 2) + 1
                if self.board.turn == chess.WHITE:
                    self.move_history.append(f"{move_number}. ... {san_move}")
                else:
                    self.move_history.append(f"{move_number}. {san_move}")
                self.history_listbox.delete(0, tk.END)
                for move in self.move_history:
                    self.history_listbox.insert(tk.END, move)
                self.history_listbox.yview(tk.END)
                opening_name = self.opening_display.get_opening_name(self.board)
                self.opening_label.config(text=f"Khai cuộc: {opening_name}")
            else:
                print(f"Bot cố gắng đi nước không hợp lệ: {move}")
        self.bot_thinking = False
        self.status_label.config(text="")
        self.canvas.config(state="normal")
        self.bot_time = self.time_limit
        self.start_timer()
        if self.board.is_game_over():
            self.end_game()
        else:
            self.update_turn_label()

    def reset_board(self):
        self.bot_thinking = False
        self.stop_timer()
        self.board = chess.Board()
        self.move_stack = []
        self.move_history = []
        self.history_listbox.delete(0, tk.END)
        self.selected_square = None
        self.status_label.config(text="")
        self.bot_move_label.config(text="Nước đi của Bot: N/A")
        self.eval_label.config(text="Đánh giá: N/A")
        self.timer_label.config(text="Thời gian người chơi: 10s")
        self.opening_label.config(text="Khai cuộc: Vị trí khởi đầu")
        self.game_frame.pack_forget()
        self.choose_color()

    def undo_move(self):
        if not self.bot_thinking and len(self.move_stack) > 0:
            self.board.pop()
            self.move_stack.pop()
            if self.bot_color == self.player_color:
                if len(self.move_stack) > 0:
                    self.board.pop()
                    self.move_stack.pop()
            self.move_history.pop()
            if self.bot_color == self.player_color and len(self.move_history) > 0:
                self.move_history.pop()
            self.history_listbox.delete(0, tk.END)
            for move in self.move_history:
                self.history_listbox.insert(tk.END, move)
            self.history_listbox.yview(tk.END)
            self.update_board()
            self.update_turn_label()
            self.status_label.config(text="Đã hoàn tác nước đi")
            self.bot_move_label.config(text="Nước đi của Bot: N/A")
            from constants import PIECE_VALUES, PAWN_TABLE_OPENING, PAWN_TABLE_MIDDLEGAME, PAWN_TABLE_ENDGAME, \
                KNIGHT_TABLE, BISHOP_TABLE, ROOK_TABLE, QUEEN_TABLE, KING_TABLE_OPENING, KING_TABLE_ENDGAME
            searcher = ChessSearch(
                board=self.board,
                bot_color=self.bot_color,
                piece_values=PIECE_VALUES,
                pawn_table_opening=PAWN_TABLE_OPENING,
                pawn_table_middlegame=PAWN_TABLE_MIDDLEGAME,
                pawn_table_endgame=PAWN_TABLE_ENDGAME,
                knight_table=KNIGHT_TABLE,
                bishop_table=BISHOP_TABLE,
                rook_table=ROOK_TABLE,
                queen_table=QUEEN_TABLE,
                king_table_opening=KING_TABLE_OPENING,
                king_table_endgame=KING_TABLE_ENDGAME
            )
            eval = searcher.evaluate_board()
            eval_text = "Chiếu hết" if eval == float('inf') else "-Chiếu hết" if eval == -float(
                'inf') else f"{eval / 100:.2f}"
            self.eval_label.config(text=f"Đánh giá: {eval_text}")
            opening_name = self.opening_display.get_opening_name(self.board)
            self.opening_label.config(text=f"Khai cuộc: {opening_name}")

    def save_game(self):
        if not self.board.is_game_over():
            messagebox.showinfo("Thông tin", "Ván cờ chưa kết thúc. Vui lòng hoàn thành ván cờ để lưu.")
            return
        game = chess.pgn.Game.from_board(self.board)
        game.headers["Sự kiện"] = "Ván cờ với Bot"
        game.headers["Trắng"] = "Người chơi" if self.player_color == chess.WHITE else "Bot"
        game.headers["Đen"] = "Bot" if self.player_color == chess.WHITE else "Người chơi"
        game.headers["Ngày"] = time.strftime("%Y.%m.%d")
        game.headers["Kết quả"] = self.board.result()
        with open("game.pgn", "w") as f:
            print(game, file=f)
        messagebox.showinfo("Thông tin", "Ván cờ đã được lưu dưới dạng game.pgn")

    def stop_timer(self):
        self.timer_running = False
        if self.current_timer_id is not None:
            self.root.after_cancel(self.current_timer_id)
            self.current_timer_id = None

    def start_timer(self):
        if not self.board.is_game_over():
            self.stop_timer()
            self.timer_running = True
            if self.board.turn == self.player_color:
                self.player_time = self.time_limit
                self.timer_label.config(text=f"Thời gian người chơi: {self.player_time:.1f}s")
            else:
                self.bot_time = self.time_limit
                self.timer_label.config(text=f"Thời gian Bot: {self.bot_time:.1f}s")
            self.timer_start = time.time()
            self.update_timer()

    def update_timer(self):
        if not self.timer_running or self.board.is_game_over():
            return

        elapsed = time.time() - self.timer_start
        if self.board.turn == self.player_color and not self.bot_thinking:
            self.player_time = max(0, self.time_limit - elapsed)
            if self.player_time <= 0:
                self.stop_timer()
                self.status_label.config(text="")
                self.timer_label.config(text="Thời gian người chơi: 0s")
                messagebox.showinfo("Kết thúc ván cờ", "Người chơi hết thời gian! Bot thắng!")
                self.reset_board()
                return
            self.timer_label.config(text=f"Thời gian người chơi: {self.player_time:.1f}s")
        elif self.board.turn == self.bot_color and self.bot_thinking:
            self.bot_time = max(0, self.time_limit - elapsed)
            if self.bot_time <= 0:
                self.stop_timer()
                self.status_label.config(text="")
                self.timer_label.config(text="Thời gian Bot: 0s")
                messagebox.showinfo("Kết thúc ván cờ", "Bot hết thời gian! Người chơi thắng!")
                self.reset_board()
                return
            self.timer_label.config(text=f"Thời gian Bot: {self.bot_time:.1f}s")

        if self.timer_running:
            self.current_timer_id = self.root.after(100, self.update_timer)

    def update_board(self):
        self.canvas.delete("all")
        for square in chess.SQUARES:
            file = chess.square_file(square)
            rank = chess.square_rank(square)
            if self.board_flipped:
                display_file = 7 - file
                display_rank = rank
            else:
                display_file = file
                display_rank = 7 - rank
            color = "white" if (display_file + display_rank) % 2 == 0 else "gray"
            x1, y1 = display_file * 60, display_rank * 60
            self.canvas.create_rectangle(x1, y1, x1 + 60, y1 + 60, fill=color)

            piece = self.board.piece_at(square)
            if piece:
                piece_symbol = piece.symbol()
                color_prefix = 'w' if piece_symbol.isupper() else 'b'
                piece_type = piece_symbol.upper()
                image_key = f"{color_prefix}{piece_type}"
                if image_key in self.piece_images:
                    self.canvas.create_image(x1 + 30, y1 + 30, image=self.piece_images[image_key])

    def highlight_legal_moves(self, square):
        self.update_board()
        moves = [move for move in self.board.legal_moves if move.from_square == square]
        for move in moves:
            to_square = move.to_square
            file = chess.square_file(to_square)
            rank = chess.square_rank(to_square)
            if self.board_flipped:
                display_file = 7 - file
                display_rank = rank
            else:
                display_file = file
                display_rank = 7 - rank
            x1, y1 = display_file * 60, display_rank * 60
            self.canvas.create_rectangle(x1, y1, x1 + 60, y1 + 60, outline="yellow", width=2)

    def update_turn_label(self):
        turn = "Trắng" if self.board.turn == chess.WHITE else "Đen"
        self.turn_label.config(text=f"Lượt: {turn}")

    def get_promotion_choice(self):
        promotion_window = tk.Toplevel(self.root)
        promotion_window.title("Chọn quân thăng cấp")
        promotion_window.geometry("200x200")
        promotion_window.grab_set()

        choice = tk.StringVar(value="q")
        tk.Button(promotion_window, text="Hậu", command=lambda: choice.set("q")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Xe", command=lambda: choice.set("r")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Tượng", command=lambda: choice.set("b")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Mã", command=lambda: choice.set("n")).pack(fill=tk.X, pady=5)
        tk.Button(promotion_window, text="Xác nhận", command=promotion_window.destroy).pack(pady=10)

        promotion_window.wait_window()
        piece_map = {"q": chess.QUEEN, "r": chess.ROOK, "b": chess.BISHOP, "n": chess.KNIGHT}
        return piece_map.get(choice.get(), chess.QUEEN)

    def player_move(self, event):
        if not self.board.is_game_over() and not self.bot_thinking and self.board.turn == self.player_color:
            x, y = event.x // 60, event.y // 60
            if not (0 <= x <= 7 and 0 <= y <= 7):
                return
            if self.board_flipped:
                file = 7 - x
                rank = y
            else:
                file = x
                rank = 7 - y
            square = chess.square(file, rank)

            if self.selected_square is None:
                if self.board.piece_at(square) and self.board.piece_at(square).color == self.board.turn:
                    self.selected_square = square
                    self.highlight_legal_moves(square)
            else:
                move = chess.Move(self.selected_square, square)

                if (self.board.piece_at(self.selected_square).piece_type == chess.PAWN and
                        (chess.square_rank(square) == 7 if self.board.turn == chess.WHITE else chess.square_rank(
                            square) == 0)):
                    promotion_choice = self.get_promotion_choice()
                    move = chess.Move(self.selected_square, square, promotion=promotion_choice)

                if move in self.board.legal_moves:
                    self.move_stack.append(self.board.fen())
                    san_move = self.board.san(move)
                    self.board.push(move)
                    self.update_board()
                    self.selected_square = None
                    self.player_time = self.time_limit
                    self.start_timer()
                    move_number = (len(self.move_history) // 2) + 1
                    if self.board.turn == chess.BLACK:
                        self.move_history.append(f"{move_number}. {san_move}")
                    else:
                        self.move_history.append(f"{move_number}. ... {san_move}")
                    self.history_listbox.delete(0, tk.END)
                    for move in self.move_history:
                        self.history_listbox.insert(tk.END, move)
                    self.history_listbox.yview(tk.END)
                    opening_name = self.opening_display.get_opening_name(self.board)
                    self.opening_label.config(text=f"Khai cuộc: {opening_name}")
                    if not self.board.is_game_over():
                        self.bot_move()
                    else:
                        self.end_game()
                else:
                    self.selected_square = None
                    self.update_board()
                self.update_turn_label()

    def end_game(self):
        self.bot_thinking = False
        self.timer_running = False
        self.status_label.config(text="")
        self.timer_label.config(text="")
        result = self.board.result()
        if result == "1-0":
            messagebox.showinfo("Kết thúc ván cờ", "Trắng thắng!")
        elif result == "0-1":
            messagebox.showinfo("Kết thúc ván cờ", "Đen thắng!")
        else:
            messagebox.showinfo("Kết thúc ván cờ", "Hòa!")

    def choose_color(self):
        self.game_frame.pack_forget()
        self.color_frame.pack(expand=True)

        for widget in self.color_frame.winfo_children():
            widget.destroy()

        tk.Label(self.color_frame, text="Chọn màu của bạn", font=("Arial", 14)).pack(pady=10)
        self.choice = tk.StringVar(value="white")
        tk.Button(self.color_frame, text="Trắng", font=("Arial", 12),
                  command=lambda: self.choice.set("white")).pack(fill=tk.X, padx=50, pady=5)
        tk.Button(self.color_frame, text="Đen", font=("Arial", 12),
                  command=lambda: self.choice.set("black")).pack(fill=tk.X, padx=50, pady=5)
        tk.Button(self.color_frame, text="Xác nhận", font=("Arial", 12),
                  command=self.confirm_color).pack(pady=20)

    def confirm_color(self):
        if self.choice.get() == "white":
            self.player_color = chess.WHITE
            self.bot_color = chess.BLACK
            self.board_flipped = False
        else:
            self.player_color = chess.BLACK
            self.bot_color = chess.WHITE
            self.board_flipped = True

        self.color_frame.pack_forget()
        self.game_frame.pack(expand=True)
        self.update_board()
        if self.bot_color == chess.WHITE:
            self.bot_move()